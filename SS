loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))()
-- VARIABLES & SERVICES
-----------------------
local V = {
    -- Libraries
    Lib = loadstring(game:HttpGet('https://raw.githubusercontent.com/OnChangedCallback/SimpleScript/refs/heads/main/fixes%3F'))(),
    Theme = loadstring(game:HttpGet('https://raw.githubusercontent.com/OnChangedCallback/SimpleScript/refs/heads/main/Themes'))(),
    Save = loadstring(game:HttpGet('https://raw.githubusercontent.com/OnChangedCallback/SimpleScript/refs/heads/main/SAves'))(),
    
    -- Services
    Players = game:GetService("Players"),
    UIS = game:GetService("UserInputService"),
    RS = game:GetService("RunService"),
    WS = workspace,
    RSStorage = game:GetService("ReplicatedStorage"),
    TweenService = game:GetService("TweenService"),
    TS = game:GetService("TweenService"),
    
    -- Objects
    LP = game:GetService("Players").LocalPlayer,
    Cam = workspace.CurrentCamera,
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    
    -- Utility
    V3 = Vector3.new,
    V2 = Vector2.new,
    CF = CFrame.new,
    RGB = Color3.fromRGB,
    HSV = Color3.fromHSV,
    INST = Instance.new,
    TWEEN = function(...) return V.TS:Create(...) end,
    Drawing = Drawing,
    math = math,
    tHighlight = nil,
    
    -- Target event handlers
    TargetCharacterRemovingConnection = nil,
    TargetCharacterAddedConnection = nil,
    
    -- Current target
    Target = nil,
    
    -- Highlight
    CurrentHighlight = nil,
    
    -- Aimbot prediction
    LastPosition = nil,
    LastUpdateTime = nil,
    
    -- CSync
    CSyncConnection = nil,
    SavedDesync = nil,
    StrafeCFrame = nil,
    CSyncHookActive = false,

    -- Aura system cache
    AuraEmitters = {},
    AuraCharacterConn = nil,
    CSyncVisualization = nil,
    ViewConnection = nil,
    MagicBulletConnection = nil,
    LastMagicShoot = 0,
    
    -- BulletTracers
    BulletTracerConnection = nil,
    ActiveTracers = {},
    
    -- Hide (Desync)
    HideConnection = nil,
    OriginalCFrame = nil,
    VoidPosition = nil,
    RandomRadius = 1e5,
    HideHook = nil,
    HideKeyConn = nil,
    
    -- GunExploit (Simplified)
    CurrentWeapon = nil,
    AutoReloadConnection = nil,
    LastReloadTime = 0,
    
    -- AntiStomp
    AntiStompConnection = nil,
    
    -- SpeedHack
    SpeedHackConnection = nil,
    
    -- FlyHack
    FlyHackConnection = nil,
    MainLoopConnection = nil,
    -- Chams
    ChamsObjects = {},
    ChamsConnections = {},
    MaterialChamsConnection = nil,
    SelfMaterialConnection = nil,
    OriginalBodyColors = {},  -- Сохраняем оригинальные цвета частей тела
    -- Tracers
    TracerLines = {},
    TracerConnections = {},
    TracerLoopConnection = nil,
    -- Boxes ESP
    BoxesCache = {},
    BoxesConnection = nil,
    BoxesPlayerConnections = {},
    -- ShowHitbox
    CurrentHitbox = nil,
    OriginalHitboxTransparency = nil,
    OriginalHitboxMaterial = nil,
    
    -- DamageDetection
    LastTargetHealth = nil,
    LastTargetMaxHealth = nil,
    DamageDetectionConnection = nil,
    
    -- HitChams
    HitChamsFolder = nil,
    ShouldShowHitChams = nil,
    
    -- Gravity
    GravityConnection = nil,
    OriginalGravity = nil,
    GravityChanged = false,
    StrafeConnection = nil,
    
    -- Strafe
    Strafe = nil,
    
    -- SelfHighlight
    SelfHighlight = nil,
    SelfHighlightConnection = nil,
    SelfHighlightChildConn = nil,
    
    -- ConeHat
    ConeHatConnection = nil,
    ConeHatDrawings = {},
    
    LastReload = 0,
    
    -- Cached objects для оптимизации
    RaycastParams = RaycastParams.new(),
    OverlapParams = OverlapParams.new(),
    
    -- Кеш для часто используемых значений
    MouseLocation = nil,
    ScreenPoint = nil,
    OnScreen = false,
    
    -- Кеш для Tracers
    TracerStartVector = nil,
    TracerScreenSize = nil,
    TracerPos = nil,
    TracerVis = false,
    TracerTemp = nil,
    
    -- Переменные времени для оптимизации
    LastRapidFireUpdate = 0,
    LastAutoReloadCheck = 0,
    LastHighlightUpdate = 0,
    
    -- Счетчики для оптимизации
    HighlightUpdateCounter = 0,
    
    -- Кеш для хайлайтов
    LastHighlightTarget = nil,
    LastHighlightConfig = {
        OutlineColor = nil,
        FillColor = nil,
        OutlineTransparency = nil,
        FillTransparency = nil
    },
    
    -- Кеш для BulletTracers
    BulletRaycastParams = nil,
    
    -- Временные переменные для CreateBeamTracer
    BeamTracerSize = Vector3.new(0, 0, 0),
    
    -- Состояние AutoStomp
    AutoStompState = {
        active = false,
        lastTime = 0,
        delayStart = 0,
        followPart = nil,
        csyncPaused = false,
        hidePaused = false,
        blockedTargets = {},
        soundId = "rbxassetid://2783295579",
        collisionDisabled = false,
        targetPlayer = nil
    },
    
    -- Trails
    TrailInstance = nil,
    TrailAttach0 = nil,
    TrailAttach1 = nil,
    _TrailCharConn = nil,
    
    -- Crosshair cache (группируем в одну таблицу)
    Crosshair = {
        Lines = {},
        Outlines = {},
        LineOffsets = {},
        SpinAngle = 0,
        CursorSize = 0,
        TextMain = nil,
        TextAccent = nil,
        Connection = nil,
        -- Temp variables
        TempMousePos = nil,
        TempDirection = nil,
        TempAngle = 0,
        TempRadius = 0
    },
    
    -- UI Elements cache (кешируем UI элементы)
    UI = {
        -- Groupboxes будут добавляться сюда
        Boxes = {},
        -- Временные переменные для UI
        TempToggle = nil,
        TempSlider = nil,
        TempDropdown = nil,
        TempColorPicker = nil,
        TempKeybind = nil
    },
    
    -- Jump Circles state/cache
    JumpCircles = {
        Connections = {},
        -- Текстуры окружностей (первая и вторая)
        Texture1 = 'rbxassetid://7216856276',
        Texture2 = 'rbxassetid://6707322206',
        -- Оставляем старое поле для совместимости (не используется напрямую)
        Texture = 'rbxassetid://5554832895'
    },

    -- Textures system state/cache
    Textures = {
        Connections = {},
        Selected = 'Plastic'
    },
    -- Список материалов Roblox (заполним при инициализации один раз)
    MaterialList = nil,
    
    -- Character parts cache (кешируем части персонажа)
    CharCache = {
        Humanoid = nil,
        RootPart = nil,
        Head = nil,
        Torso = nil,
        -- Временные переменные
        TempChar = nil, 
        TempHum = nil,
        TempRoot = nil
    },
    
    -- Temporary variables cache (временные переменные для функций)
    Temp = {
        -- Для CreateCSyncVisualization
        CSyncBillboard = nil,
        CSyncImage = nil,
        CSyncPart = nil,
        -- Для BulletTracers
        TracerLine = nil,
        TracerCircle = nil,
        -- Для различных проверок
        Distance = 0,
        Magnitude = 0,
        ScreenPos = nil,
        OnScreen = false,
        -- Для итераций
        Player = nil,
        Character = nil,
        Part = nil,
        Index = 0,
        Value = nil,
        -- Для ShootAtPlayer
        WeaponTool = nil,
        Ammo = nil,
        Head = nil,
        Weapon = nil,
        Handle = nil,
        HeadPos = nil,
        Args = nil,
        ShootEvent = nil,
        -- Для HitChams
        Clone = nil,
        TweenInfo = nil,
        Tween = nil,
        Lines = {},
        Line = nil,
        Thickness = 0,
        ParentBone = nil,
        ChildBone = nil,
        -- Общие временные переменные
        TempTable = {},
        TempString = "",
        TempNumber = 0,
        TempBool = false,
        TempCFrame = nil,
        TempVector3 = nil,
        TempColor3 = nil
    },
    
    -- Cache для часто используемых Instance.new (НЕ сами объекты, а временные ссылки)
    InstCache = {
        -- Временные ссылки на создаваемые объекты
        TempPart = nil,
        TempAttachment = nil,
        TempBeam = nil,
        TempHighlight = nil,
        TempBillboard = nil,
        TempImage = nil
    },
    
    -- Weapon cache (кеш для оружия)
    WeaponCache = {
        Ammo = nil,
        ReloadEvent = nil,
        Revolver = nil,
        Tool = nil,
        GunScript = nil,
        Handle = nil
    },
    
    -- Function cache (кеш для функций)
    FuncCache = {
        Connection = nil,
        Func = nil,
        Info = nil,
        Val = nil,
        CurrentTime = 0,
        Now = 0
    },
    
    -- Loop cache (кеш для циклов)
    LoopCache = {
        i = 0,
        j = 0,
        k = 0,
        v = nil,
        key = nil,
        value = nil,
        index = 0,
        item = nil,
        element = nil,
        obj = nil,
        part = nil,
        plr = nil,
        char = nil,
        hum = nil,
        root = nil
    },
    
    -- Math cache (кеш для математических операций)
    MathCache = {
        Distance = 0,
        Magnitude = 0,
        Angle = 0,
        Delta = 0,
        Time = 0,
        Num = 0,
        X = 0,
        Y = 0,
        Z = 0
    },
    
    -- ESP cache (кеш для ESP)
    ESPCache = {
        Box = nil,
        Name = nil,
        Health = nil,
        Distance = nil,
        Tracer = nil,
        Color = nil,
        Position = nil,
        ScreenPos = nil,
        OnScreen = false
    },
    
    -- Tween cache (кеш для твинов)
    TweenCache = {
        Info = nil,
        Tween = nil,
        Goal = {},
        Duration = 0,
        Style = nil,
        Direction = nil
    },
    
    -- Raycast cache (кеш для рейкастов)
    RaycastCache = {
        Result = nil,
        Origin = nil,
        Direction = nil,
        Instance = nil,
        Position = nil,
        Normal = nil
    },
    
    -- Color cache (кеш для цветов)
    ColorCache = {
        R = 0,
        G = 0,
        B = 0,
        H = 0,
        S = 0,
        V = 0,
        Color = nil,
        Transparency = 0
    },
    
    -- Sound cache (кеш для звуков)
    SoundCache = {
        Sound = nil,
        Id = nil,
        Volume = 0,
        Pitch = 0,
        Playing = false
    },
    
    -- Animation cache (кеш для анимаций)
    AnimCache = {
        Track = nil,
        Animation = nil,
        Speed = 0,
        Weight = 0,
        Playing = false
    }
}

-- FOLLOW PART INIT (камера всегда следует за FollowPart)


-- Setup libraries
V.Theme:SetLibrary(V.Lib)
V.Save:SetLibrary(V.Lib)

V.Win = V.Lib:CreateWindow({
    Title = 'SimpleBot | Really simple | ' .. os.date('%d.%m.%Y'),
    Themeable = true,
    Info = 'SimpleBot',
    Center = true,
    AutoShow = true,
    Size = UDim2.fromOffset(550, 700)
})

-- Create tabs
V.Tabs = {
    Aimbot = V.Win:AddTab('Aimbot'),
    Misc = V.Win:AddTab('Misc'),
    Player = V.Win:AddTab('Player'),
    Visuals = V.Win:AddTab('Visuals'),
    Config = V.Win:AddTab('Config')
}

-----------------------
-- CONFIG
-----------------------
local Config = {
    Aimbot = {
        Enabled = true,
        StickyKey = Enum.KeyCode.Q,
        SkipCovered = false,
        SkipKnocked = false,
        SkipGrabbed = false,
        ResetKnocked = false,
        ResetGrabbed = false,
        ResetDeath = false,
        -- Aimbot Settings
        AimbotEnabled = false,
        Prediction = 0.1,
        ResolverMode = 'None',
        SelectedPart = 'HumanoidRootPart',
        TargetMode = 'Sticky',
        CSyncEnabled = false,
    CSyncRange = 10,
    CSyncHeight = 5,
    CSyncVisualize = false, 
    CSyncVisualizeColor = Color3.new(1, 1, 1),
    MagicBullets = false,
        ViewTarget = false,
        AutoStompEnabled = false, -- новый автостомп
        DelayBeforeStomp = 0.25,
        StompInterval = 0.4,
        
        -- GunExploit Settings (Simplified)
        GunExploitEnabled = false,
        AutoReload = false,
        AutoEquipRevolver = false,
        
        YOffset = 2,
        
        -- ShowHitbox Settings
        ShowHitbox = false,
        HitboxColor = Color3.new(1, 0, 0),
        HitboxMaterial = 'ForceField'
    },
    TargetHighlight = {
        Enabled = false,
        OutlineColor = Color3.new(1, 0, 0),
        FillColor = Color3.new(1, 0, 0),
        OutlineTransparency = 0,
        FillTransparency = 0.5
    },
    Chams = {
        Enabled = false,
        Color = Color3.new(0, 150/255, 1), -- default cyan-ish
        Transparency = 0.3
    },
    MaterialChams = {
        Enabled = false,
        Color = Color3.new(0, 150/255, 1) -- default cyan-ish
    },
    SelfMaterial = {
        Enabled = false,
        Color = Color3.new(0, 150/255, 1) -- default cyan-ish
    },
    Tracers = {
        Enabled = false,
        Color = Color3.new(1,1,1),
        Transparency = 0,
        Thickness = 1,
        StartPosition = 'Bottom', -- 'Mouse', 'Middle', 'Bottom', 'Top'
        EndPart = 'Torso', -- 'Torso' or 'Head'
        ShowBehind = true,
        TargetTracerEnabled = false,
        TargetTracerColor = Color3.new(1,0,0)
    },
    Boxes = {
        Enabled = false,
        Color = Color3.new(1, 0, 0),
        Thickness = 0.9,
        HealthBarEnabled = false,
        HealthBarColor = Color3.new(0, 1, 0),
        HealthBarBgColor = Color3.new(40/255, 40/255, 40/255),
        HealthBarWidth = 2,
        MaxDistance = 500
    },

    BulletTracers = {
        Enabled = false,
        Mode = "Drawing", -- Drawing или Texture
        Color = Color3.new(1, 1, 1),
        Thickness = 2,
        Duration = 0.6
    },
    AntiStomp = {
        Enabled = false,
        Method = "Nil_Char",
        EnableOnHealth = 99
    },

    FlyHack = {
        Enabled = false,
        Active = false,
        Speed = 1,
        Key = Enum.KeyCode.F
    },
    
    Hide = {
        Enabled = false,
        Mode = "Original",
        Key = Enum.KeyCode.H -- хоткей переключения Hide
    },
    
    DamageDetection = {
        Enabled = true, -- всегда включена
        ShowDamage = true,
        ShowHealth = true,
        ShowPercentage = true
    },
    
    HitChams = {
        Enabled = false,
        Material = "Neon",
        Duration = 2,
        Color = Color3.new(1, 0, 0),
        Transparency = 0,
        Skeleton = false,
        SkeletonColor = Color3.new(155/255, 0, 155/255),
        SkeletonDuration = 1.5,
        SkeletonTransparency = 0,
        SkeletonThickness = 0.1
    },

    RapidFire = {
        Enabled = false
    },

    GunRangeExploit = {
        Enabled = false,
        Range = 1000
    },

    HitSound = {
        Enabled = false,
        Sound = "CSGO.mp3",
        Volume = 1,
        Pitch = 1,
        MuteOriginal = false
    },
    
    Gravity = {
        Enabled = false,
        Mode = "Workspace", -- "Workspace", "Impulse", "LinearVelocity"
        Value = 196.2
    },
    
    Strafe = {
        Enabled = false,
        Strength = 2
    },
    
    ConeHat = {
        Enabled = false,
        ColorMode = 'Custom', -- 'Custom' или 'Rainbow'
        -- Градиент для Custom режима
        GradientColor1 = Color3.fromRGB(128, 18, 255),
        GradientColor2 = Color3.fromRGB(255, 18, 128),
        GradientColor3 = Color3.fromRGB(18, 255, 128),
        -- Основные настройки
        Height = 0.75,
        Radius = 1,
        CircleTransparency = 1,
        -- Статичные настройки (без UI)
        MinCameraDistance = 1,
        HatTransparency = 0.35,
        Sides = 25,
        Offset = Vector3.new(0, 0.75, 0)
     },
 
     -- World Settings
     WorldSettings = {
         Color = Color3.fromRGB(220, 244, 250),
         Decay = Color3.fromRGB(202, 202, 202),
         Glare = 0.5,
         Haze = 1.5,
         Density = 0.35,
         Offset = 0.2
     },
 
     -- Ambient Settings
     Ambient = {
         Enabled = false,
         Color = Color3.fromRGB(128, 128, 128)
     },
 
     -- Bloom Settings
     Bloom = {
         Enabled = false,
         Intensity = 0.5,
         Threshold = 1.0,
         Size = 24
     },
 
     -- Jump Circles Settings
     JumpCircles = {
         Enabled = false,
         Color1 = Color3.fromRGB(255, 255, 255),
         Color2 = Color3.fromRGB(255, 255, 255),
         Size = 15,
         LifeAfterMax = 0.3 -- задержка жизни на максимальном размере (сек)
     },
 
     -- Textures override Settings
     Textures = {
         Enabled = false,
         Selected = 'Plastic'
     },
 
     -- Trails Settings
     Trails = {
         Enabled = false,
         Color = Color3.fromRGB(255, 0, 0),
         Transparency = 0.5,
         Length = 10,
         Width = 2,
         MinLength = 0.1,
         FaceCamera = true
     },

     -- Color Correction Settings
     ColorCorrection = {
         Enabled = false,
         Brightness = 0.0,   -- range: -1 .. 1
         Contrast = 0.0,     -- range: -1 .. 1
         Saturation = 0.0,   -- range: -1 .. 1
         TintColor = Color3.fromRGB(255, 255, 255)
     },
 
     -- Time Settings
     Time = {
         Enabled = false,
         Hours = 12,
         Minutes = 0
     },
 
     -- Aura Settings
     Aura = {
         Enabled = false,
         Type = 'Health', -- 'Health' (example aura)
         Color = Color3.new(1, 1, 1)
     },
    
    -- Crosshair Settings
    Crosshair = {
        Enabled = false,
        AlwaysRotating = true,
        Speed = 5,
        GapSize = 15,
        Length = 20,
        Thickness = 2.5,
        Sides = 4,
        Pulse = false,
        AttachToTarget = false,
        ShowText = true,
        CrosshairColor = Color3.fromRGB(255, 255, 255),
        OutlineColor = Color3.fromRGB(0, 0, 0),
        TextColor = Color3.fromRGB(255, 255, 255)
    },

    -- GamingChair Settings
    GamingChair = {
        Enabled = false,
        Color = Color3.fromRGB(255, 0, 0)
    }
 }

-----------------------
-- UTILITY FUNCTIONS
-----------------------

-----------------------
-- GAMINGCHAIR MODULE
-----------------------

-- State container in V
V.GamingChair = V.GamingChair or {
    Enabled = false,
    Connection = nil,
    Chair = nil,
    ChairArms = nil,
    ChairLegs = nil,
    ChairFan = nil,
    Weld = nil,
    MoveSound = nil,
    FlySound = nil,
    Anim = nil,
    Trails = {},
    OldMoving = false,
    OldFlying = false,
    Highlight = nil
}

function V.GamingChair.Enable()
    if V.GamingChair.Connection then return end
    V.GamingChair.Enabled = true

    local chair = V.INST('MeshPart')
    chair.Color = V.RGB(21, 21, 21)
    chair.Size = V.V3(2.16, 3.6, 2.3) / V.V3(12.37, 20.636, 13.071)
    chair.CanCollide = false
    chair.Massless = true
    chair.MeshId = 'rbxassetid://12972961089'
    chair.Material = Enum.Material.SmoothPlastic
    chair.Parent = V.WS
    V.GamingChair.Chair = chair

    local move = V.INST('Sound')
    move.Volume = 0.4
    move.Looped = true
    move.Parent = V.WS
    V.GamingChair.MoveSound = move

    local fly = V.INST('Sound')
    fly.Volume = 0.4
    fly.Looped = true
    fly.Parent = V.WS
    V.GamingChair.FlySound = fly

    local weld = V.INST('WeldConstraint')
    weld.Part0 = chair
    weld.Parent = chair
    V.GamingChair.Weld = weld

    if V.LP.Character and V.LP.Character:FindFirstChild('HumanoidRootPart') then
        chair.CFrame = V.LP.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(-90), 0)
        weld.Part1 = V.LP.Character.HumanoidRootPart
    end

    local h = V.INST('Highlight')
    h.FillTransparency = 1
    h.OutlineColor = Config.GamingChair.Color
    h.DepthMode = Enum.HighlightDepthMode.Occluded
    h.OutlineTransparency = 0.2
    h.Parent = chair
    V.GamingChair.Highlight = h

    local arms = V.INST('MeshPart')
    arms.Color = chair.Color
    arms.Size = V.V3(1.39, 1.345, 2.75) / V.V3(97.13, 136.216, 234.031)
    arms.CFrame = chair.CFrame * CFrame.new(-0.169, -1.129, -0.013)
    arms.MeshId = 'rbxassetid://12972673898'
    arms.CanCollide = false
    arms.Parent = chair
    V.GamingChair.ChairArms = arms

    local armsw = V.INST('WeldConstraint')
    armsw.Part0 = arms
    armsw.Part1 = chair
    armsw.Parent = chair

    local legs = V.INST('MeshPart')
    legs.Color = chair.Color
    legs.Name = 'Legs'
    legs.Size = V.V3(1.8, 1.2, 1.8) / V.V3(10.432, 8.105, 9.488)
    legs.CFrame = chair.CFrame * CFrame.new(0.047, -2.324, 0)
    legs.MeshId = 'rbxassetid://13003181606'
    legs.CanCollide = false
    legs.Parent = chair
    V.GamingChair.ChairLegs = legs

    local fan = V.INST('MeshPart')
    fan.Color = chair.Color
    fan.Name = 'Fan'
    fan.Size = V.V3(0, 0, 0)
    fan.CFrame = chair.CFrame * CFrame.new(0, -1.873, 0)
    fan.MeshId = 'rbxassetid://13004977292'
    fan.CanCollide = false
    fan.Parent = chair
    V.GamingChair.ChairFan = fan

    -- Trails on wheels
    local wheelpositions = {
        V.V3(-0.8, -0.6, -0.18),
        V.V3(0.1, -0.6, -0.88),
        V.V3(0, -0.6, 0.7)
    }
    V.GamingChair.Trails = {}
    for _, pos in ipairs(wheelpositions) do
        local a0 = V.INST('Attachment')
        a0.Position = pos
        a0.Parent = legs
        local a1 = V.INST('Attachment')
        a1.Position = pos + V.V3(0, 0, 0.18)
        a1.Parent = legs
        local tr = V.INST('Trail')
        tr.Texture = 'http://www.roblox.com/asset/?id=13005168530'
        tr.TextureMode = Enum.TextureMode.Static
        tr.Transparency = NumberSequence.new(0.5)
        tr.Color = ColorSequence.new(Color3.new(0.5, 0.5, 0.5))
        tr.Attachment0 = a0
        tr.Attachment1 = a1
        tr.Lifetime = 20
        tr.MaxLength = 60
        tr.MinLength = 0.1
        tr.Parent = legs
        table.insert(V.GamingChair.Trails, tr)
    end

    -- Animation holder
    V.GamingChair.Anim = { Stop = function() end, IsPlaying = false }

    -- Main loop
    V.GamingChair.Connection = V.RS.RenderStepped:Connect(function()
        local char = V.LP.Character
        local hum = char and char:FindFirstChildOfClass('Humanoid')
        local root = char and char:FindFirstChild('HumanoidRootPart')
        if char and hum and root and hum.Health > 0 then
            if not (V.GamingChair.Anim and V.GamingChair.Anim.IsPlaying) then
                local anim = V.INST('Animation')
                anim.AnimationId = (hum.RigType == Enum.HumanoidRigType.R15) and 'http://www.roblox.com/asset/?id=2506281703' or 'http://www.roblox.com/asset/?id=178130996'
                local track = hum:LoadAnimation(anim)
                track.Priority = Enum.AnimationPriority.Movement
                track.Looped = true
                track:Play()
                V.GamingChair.Anim = track
            end

            chair.CFrame = root.CFrame * CFrame.Angles(0, math.rad(-90), 0)
            weld.Part1 = root

            legs.Velocity = V.V3(0,0,0)
            legs.CFrame = chair.CFrame * CFrame.new(0.047, -2.324, 0)
            fan.Velocity = V.V3(0,0,0)
            fan.CFrame = chair.CFrame * CFrame.new(0.047, -1.873, 0) * CFrame.Angles(0, math.rad((tick() * 180) % 360), math.rad(180))

            local moving = hum:GetState() == Enum.HumanoidStateType.Running and hum.MoveDirection ~= V.V3(0,0,0)
            local flying = (Config.FlyHack and Config.FlyHack.Enabled) or false

            if V.GamingChair.MoveSound.TimePosition > 1.9 then
                V.GamingChair.MoveSound.TimePosition = 0.2
            end
            V.GamingChair.MoveSound.PlaybackSpeed = (root.Velocity * V.V3(1, 0, 1)).Magnitude / 16
            for _, tr in ipairs(V.GamingChair.Trails) do
                tr.Enabled = (not flying) and moving
                tr.Color = ColorSequence.new((V.GamingChair.MoveSound.PlaybackSpeed > 1.5) and Color3.new(1, 0.5, 0) or Color3.new())
            end

            if moving ~= V.GamingChair.OldMoving then
                if V.GamingChair.MoveSound.IsPlaying then
                    if not moving then
                        V.GamingChair.MoveSound:Stop()
                    end
                else
                    if (not flying) and moving then
                        V.GamingChair.MoveSound:Play()
                    end
                end
                V.GamingChair.OldMoving = moving
            end

            if flying ~= V.GamingChair.OldFlying then
                if flying then
                    if V.GamingChair.MoveSound.IsPlaying then V.GamingChair.MoveSound:Stop() end
                    if not V.GamingChair.FlySound.IsPlaying then V.GamingChair.FlySound:Play() end
                    -- legs to fan
                    local t1 = V.TS:Create(legs, TweenInfo.new(0.15), { Size = V.V3(0,0,0) })
                    t1.Completed:Connect(function(state)
                        if state == Enum.PlaybackState.Completed then
                            fan.Transparency = 0
                            legs.Transparency = 1
                            V.TS:Create(fan, TweenInfo.new(0.15), { Size = V.V3(1.534, 0.328, 1.537) / V.V3(791.138, 168.824, 792.027) }):Play()
                        end
                    end)
                    t1:Play()
                else
                    if V.GamingChair.FlySound.IsPlaying then V.GamingChair.FlySound:Stop() end
                    if (not V.GamingChair.MoveSound.IsPlaying) and moving then V.GamingChair.MoveSound:Play() end
                    -- fan to legs
                    local t2 = V.TS:Create(fan, TweenInfo.new(0.15), { Size = V.V3(0,0,0) })
                    t2.Completed:Connect(function(state)
                        if state == Enum.PlaybackState.Completed then
                            fan.Transparency = 1
                            legs.Transparency = 0
                            V.TS:Create(legs, TweenInfo.new(0.15), { Size = V.V3(1.8, 1.2, 1.8) / V.V3(10.432, 8.105, 9.488) }):Play()
                        end
                    end)
                    t2:Play()
                end
                V.GamingChair.OldFlying = flying
            end
        else
            if chair then chair.Anchored = true end
            if legs then legs.Anchored = true end
            if fan then fan.Anchored = true end
        end
    end)
end

function V.GamingChair.Disable()
    V.GamingChair.Enabled = false
    if V.GamingChair.Connection then V.GamingChair.Connection:Disconnect() V.GamingChair.Connection = nil end
    if V.GamingChair.Anim and V.GamingChair.Anim.Stop then pcall(function() V.GamingChair.Anim:Stop() end) end
    if V.GamingChair.MoveSound then V.GamingChair.MoveSound:Destroy() V.GamingChair.MoveSound = nil end
    if V.GamingChair.FlySound then V.GamingChair.FlySound:Destroy() V.GamingChair.FlySound = nil end
    if V.GamingChair.Highlight then V.GamingChair.Highlight:Destroy() V.GamingChair.Highlight = nil end
    if V.GamingChair.Chair then V.GamingChair.Chair:Destroy() V.GamingChair.Chair = nil end
    V.GamingChair.ChairArms = nil
    V.GamingChair.ChairLegs = nil
    V.GamingChair.ChairFan = nil
    V.GamingChair.Weld = nil
    for i = #V.GamingChair.Trails, 1, -1 do
        local tr = table.remove(V.GamingChair.Trails, i)
        if tr then tr:Destroy() end
    end
end

function V.GamingChair.Toggle(on)
    Config.GamingChair.Enabled = on
    if on then V.GamingChair.Enable() else V.GamingChair.Disable() end
end

-- UI (Visuals tab, right group)
if V.Tabs and V.Tabs.Visuals then
    V.UI.Boxes = V.UI.Boxes or {}
    V.UI.Boxes.GamingChair = V.Tabs.Visuals:AddRightGroupbox('GamingChair')

    if V.UI.Boxes.GamingChair then
        local _gcToggle = V.UI.Boxes.GamingChair:AddToggle('GamingChairEnabled', {
            Text = 'Enabled',
            Default = Config.GamingChair.Enabled,
            Tooltip = 'Sit in the best gaming chair known to mankind.',
            Callback = function(v)
                V.GamingChair.Toggle(v)
            end
        })

        if _gcToggle and _gcToggle.AddColorPicker then
            _gcToggle:AddColorPicker('GamingChairColor', {
                Title = 'Color',
                Default = Config.GamingChair.Color,
                Callback = function(a,b,c)
                    local col
                    if typeof(a) == 'Color3' then
                        col = a
                    else
                        local h = a or 0
                        local s = b or 0
                        local v = c or 0
                        col = Color3.fromHSV(h, s, v)
                    end
                    Config.GamingChair.Color = col
                    if V.GamingChair.Highlight then
                        V.GamingChair.Highlight.OutlineColor = col
                    end
                end
            })
        elseif V.UI.Boxes.GamingChair.AddColorPicker then
            V.UI.Boxes.GamingChair:AddColorPicker('GamingChairColor', {
                Title = 'Color',
                Default = Config.GamingChair.Color,
                Callback = function(a,b,c)
                    local col
                    if typeof(a) == 'Color3' then
                        col = a
                    else
                        local h = a or 0
                        local s = b or 0
                        local v = c or 0
                        col = Color3.fromHSV(h, s, v)
                    end
                    Config.GamingChair.Color = col
                    if V.GamingChair.Highlight then
                        V.GamingChair.Highlight.OutlineColor = col
                    end
                end
            })
        end
    end
end

-- Apply initial state
if Config.GamingChair.Enabled then V.GamingChair.Enable() end

local function IsVisible(targetRoot)
    if not Config.Aimbot.SkipCovered then return true end
    
    -- Используем кешированный RaycastParams
    V.RaycastParams.FilterDescendantsInstances = {V.LP.Character, targetRoot.Parent}
    V.RaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    return V.WS:Raycast(V.Cam.CFrame.Position, (targetRoot.Position - V.Cam.CFrame.Position), V.RaycastParams) == nil
end

-- Predeclare for Luau type checker
V.FrozenTemplate = V.FrozenTemplate or nil
-- New: Frozen aura built from provided model data (used as a template)
function V._GetFrozenTemplate()
    if V.FrozenTemplate and V.FrozenTemplate.Parent == nil then
        return V.FrozenTemplate
    end
    if V.FrozenTemplate and V.FrozenTemplate.Parent then
        return V.FrozenTemplate
    end

    local partsWithId = {}
    local awaitRef = {}

    local root = {
    	ID = 0;
    	Type = "Model";
    	Properties = {
    		Name = "Frozen Dummy";
    		PrimaryPart = "_R:27_";
    	};
    	Children = {
    		{
    			ID = 1;
    			Type = "MeshPart";
    			Properties = {
    				MeshId = "rbxassetid://11697594553";
    				Reflectance = 0.44999998807907104;
    				Position = Vector3.new(-29.0831298828125,5.501658916473389,119.00080871582031);
    				Name = "Head";
    				CFrame = CFrame.new(-29.0831298828125,5.501658916473389,119.00080871582031,1,0,0,0,1,0,0,0,1);
    				Material = Enum.Material.SmoothPlastic;
    				Size = Vector3.new(1.1998358964920044,1.2044157981872559,1.1998361349105835);
    			};
    			Children = {
    				{ ID = 2; Type = "Decal"; Properties = { Name = "face"; Texture = "rbxasset://textures/face.png"; }; Children = {} },
    				{ ID = 3; Type = "Attachment"; Properties = { Name = "FaceCenterAttachment"; }; Children = {} },
    				{ ID = 4; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0,-0.5974688529968262,1,0,0,0,1,0,0,0,1); Name = "FaceFrontAttachment"; Position = Vector3.new(0,0,-0.5974688529968262); }; Children = {} },
    				{ ID = 5; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0.5974687933921814,0,1,0,0,0,1,0,0,0,1); Name = "HairAttachment"; Position = Vector3.new(0,0.5974687933921814,0); }; Children = {} },
    				{ ID = 6; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0.5974687933921814,0,1,0,0,0,1,0,0,0,1); Name = "HatAttachment"; Position = Vector3.new(0,0.5974687933921814,0); }; Children = {} },
    				{ ID = 7; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    				{ ID = 8; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(14/51,84/85,1)),ColorSequenceKeypoint.new(1,Color3.new(14/51,84/85,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    			};
    		};
    		{ ID = 9; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594395"; Reflectance = 0.44999998807907104; Name = "Left Arm"; CanCollide = false; Material = Enum.Material.SmoothPlastic; CFrame = CFrame.new(-30.5831298828125,4.001658916473389,119.00080871582031,1,0,0,0,1,0,0,0,1); Position = Vector3.new(-30.5831298828125,4.001658916473389,119.00080871582031); Size = Vector3.new(1.0016579627990723,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 10; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-1,0,1,0,0,0,1,0,0,0,1); Name = "LeftGripAttachment"; Position = Vector3.new(0,-1,0); }; Children = {} },
    			{ ID = 11; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,1,0,1,0,0,0,1,0,0,0,1); Name = "LeftShoulderAttachment"; Position = Vector3.new(0,1,0); }; Children = {} },
    			{ ID = 12; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    			{ ID = 13; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(14/51,84/85,1)),ColorSequenceKeypoint.new(1,Color3.new(14/51,84/85,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    		}; };
    		{ ID = 14; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594244"; Reflectance = 0.44999998807907104; Name = "Left Leg"; CanCollide = false; Material = Enum.Material.SmoothPlastic; CFrame = CFrame.new(-29.5831298828125,2.0016589164733887,119.00080871582031,1,0,0,0,1,0,0,0,1); Position = Vector3.new(-29.5831298828125,2.0016589164733887,119.00080871582031); Size = Vector3.new(1.0016579627990723,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 15; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-1,0,1,0,0,0,1,0,0,0,1); Name = "LeftFootAttachment"; Position = Vector3.new(0,-1,0); }; Children = {} },
    			{ ID = 16; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    			{ ID = 17; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(14/51,84/85,1)),ColorSequenceKeypoint.new(1,Color3.new(14/51,84/85,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    		}; };
    		{ ID = 18; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594450"; Reflectance = 0.44999998807907104; Name = "Right Arm"; CanCollide = false; Material = Enum.Material.SmoothPlastic; CFrame = CFrame.new(-27.5831298828125,4.001658916473389,119.00080871582031,1,0,0,0,1,0,0,0,1); Position = Vector3.new(-27.5831298828125,4.001658916473389,119.00080871582031); Size = Vector3.new(1.0016579627990723,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 19; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,1,0,1,0,0,0,1,0,0,0,1); Name = "RightShoulderAttachment"; Position = Vector3.new(0,1,0); }; Children = {} },
    			{ ID = 20; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-1,0,1,0,0,0,1,0,0,0,1); Name = "RightGripAttachment"; Position = Vector3.new(0,-1,0); }; Children = {} },
    			{ ID = 21; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    			{ ID = 22; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(14/51,84/85,1)),ColorSequenceKeypoint.new(1,Color3.new(14/51,84/85,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    		}; };
    		{ ID = 23; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594312"; Reflectance = 0.44999998807907104; Name = "Right Leg"; CanCollide = false; Material = Enum.Material.SmoothPlastic; CFrame = CFrame.new(-28.5831298828125,2.0016589164733887,119.00080871582031,1,0,0,0,1,0,0,0,1); Position = Vector3.new(-28.5831298828125,2.0016589164733887,119.00080871582031); Size = Vector3.new(1.0016579627990723,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 24; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-1,0,1,0,0,0,1,0,0,0,1); Name = "RightFootAttachment"; Position = Vector3.new(0,-1,0); }; Children = {} },
    			{ ID = 25; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    			{ ID = 26; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(14/51,84/85,1)),ColorSequenceKeypoint.new(1,Color3.new(14/51,84/85,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    		}; };
    		{ ID = 27; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594497"; Transparency = 1; Reflectance = 0.44999998807907104; Position = Vector3.new(-29.0831298828125,4.001658916473389,119.00080871582031); Name = "HumanoidRootPart"; CFrame = CFrame.new(-29.0831298828125,4.001658916473389,119.00080871582031,1,0,0,0,1,0,0,0,1); Material = Enum.Material.SmoothPlastic; Size = Vector3.new(2.0033159255981445,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 28; Type = "Attachment"; Properties = { Name = "RootAttachment"; }; Children = {} },
    			{ ID = 29; Type = "Motor6D"; Properties = { Part1 = "_R:31_"; Name = "RootJoint"; C1 = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,-0); C0 = CFrame.new(0,0,0,-1,0,0,0,0,1,0,1,-0); Part0 = "_R:27_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    		}; };
    		{ ID = 30; Type = "Humanoid"; Properties = { HealthDisplayDistance = 0; NameDisplayDistance = 0; DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None; HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff; }; Children = {} };
    		{ ID = 31; Type = "MeshPart"; Properties = { MeshId = "rbxassetid://11697594497"; Reflectance = 0.44999998807907104; Position = Vector3.new(-29.0831298828125,4.001658916473389,119.00080871582031); Name = "Torso"; CFrame = CFrame.new(-29.0831298828125,4.001658916473389,119.00080871582031,1,0,0,0,1,0,0,0,1); Material = Enum.Material.SmoothPlastic; Size = Vector3.new(2.0033159255981445,2.0033159255981445,1.0016580820083618); }; Children = {
    			{ ID = 32; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0,-0.4978906810283661,1,0,0,0,1,0,0,0,1); Name = "BodyFrontAttachment"; Position = Vector3.new(0,0,-0.4978906810283661); }; Children = {} },
    			{ ID = 33; Type = "Attachment"; Properties = { CFrame = CFrame.new(-0.9957813620567322,0.9957813024520874,0,1,0,0,0,1,0,0,0,1); Name = "LeftCollarAttachment"; Position = Vector3.new(-0.9957813620567322,0.9957813024520874,0); }; Children = {} },
    			{ ID = 34; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0.9957813024520874,0,1,0,0,0,1,0,0,0,1); Name = "NeckAttachment"; Position = Vector3.new(0,0.9957813024520874,0); }; Children = {} },
    			{ ID = 35; Type = "Attachment"; Properties = { CFrame = CFrame.new(0.9957813620567322,0.9957813024520874,0,1,0,0,0,1,0,0,0,1); Name = "RightCollarAttachment"; Position = Vector3.new(0.9957813620567322,0.9957813024520874,0); }; Children = {} },
    			{ ID = 36; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-0.9957813024520874,0.4978906810283661,1,0,0,0,1,0,0,0,1); Name = "WaistBackAttachment"; Position = Vector3.new(0,-0.9957813024520874,0.4978906810283661); }; Children = {} },
    			{ ID = 37; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-0.9957813024520874,0,1,0,0,0,1,0,0,0,1); Name = "WaistCenterAttachment"; Position = Vector3.new(0,-0.9957813024520874,0); }; Children = {} },
    			{ ID = 38; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,-0.9957813024520874,-0.4978906810283661,1,0,0,0,1,0,0,0,1); Name = "WaistFrontAttachment"; Position = Vector3.new(0,-0.9957813024520874,-0.4978906810283661); }; Children = {} },
    			{ ID = 39; Type = "Attachment"; Properties = { CFrame = CFrame.new(0,0,0.4978906810283661,1,0,0,0,1,0,0,0,1); Name = "BodyBackAttachment"; Position = Vector3.new(0,0,0.4978906810283661); }; Children = {} },
    			{ ID = 40; Type = "Motor6D"; Properties = { Part1 = "_R:14_"; Name = "Left Hip"; C1 = CFrame.new(-0.5,1,0,0,0,-1,0,1,0,1,0,0); C0 = CFrame.new(-1,-1,0,0,0,-1,0,1,0,1,0,0); Part0 = "_R:31_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    			{ ID = 41; Type = "Motor6D"; Properties = { Part1 = "_R:9_"; Name = "Left Shoulder"; C1 = CFrame.new(0.5,0.5,0,0,0,-1,0,1,0,1,0,0); C0 = CFrame.new(-1,0.5,0,0,0,-1,0,1,0,1,0,0); Part0 = "_R:31_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    			{ ID = 42; Type = "Motor6D"; Properties = { Part1 = "_R:1_"; Name = "Neck"; C1 = CFrame.new(0,-0.5,0,-1,0,0,0,0,1,0,1,-0); C0 = CFrame.new(0,1,0,-1,0,0,0,0,1,0,1,-0); Part0 = "_R:31_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    			{ ID = 43; Type = "Motor6D"; Properties = { Part1 = "_R:23_"; Name = "Right Hip"; C1 = CFrame.new(0.5,1,0,0,0,1,0,1,-0,-1,0,0); C0 = CFrame.new(1,-1,0,0,0,1,0,1,-0,-1,0,0); Part0 = "_R:31_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    			{ ID = 44; Type = "Motor6D"; Properties = { Part1 = "_R:18_"; Name = "Right Shoulder"; C1 = CFrame.new(-0.5,0.5,0,0,0,1,0,1,-0,-1,0,0); C0 = CFrame.new(1,0.5,0,0,0,1,0,1,-0,-1,0,0); Part0 = "_R:31_"; MaxVelocity = 0.10000000149011612; }; Children = {} },
    			{ ID = 45; Type = "ParticleEmitter"; Properties = { VelocitySpread = 5; Texture = "rbxassetid://13410359900"; RotSpeed = NumberRange.new(-30,30); LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(79/255,232/255,1)),ColorSequenceKeypoint.new(1,Color3.new(79/255,232/255,1))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(5,5); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.4860000014305115,0.6000000238418579,0),NumberSequenceKeypoint.new(0.6050000190734863,0.6000000238418579,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Aura"; Lifetime = NumberRange.new(0.6000000238418579); Speed = NumberRange.new(0,1); Rate = 25; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3125,0),NumberSequenceKeypoint.new(1,1.4375001192092896,0)}); }; Children = {} },
    			{ ID = 46; Type = "Attachment"; Properties = { Name = "Main"; }; Children = {
    				{ ID = 47; Type = "ParticleEmitter"; Properties = { Texture = "rbxassetid://1075864321"; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(23/51,229/255,1)),ColorSequenceKeypoint.new(1,Color3.new(23/51,229/255,1))}); LockedToPart = true; ZOffset = -1; LightEmission = 1; EmissionDirection = Enum.NormalId.Front; Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.49947309494018555,0.7357512712478638,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Light"; Lifetime = NumberRange.new(1.2999999523162842); Speed = NumberRange.new(0.0010000000474974513); Rotation = NumberRange.new(-360,360); Rate = 2; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,4.5,0),NumberSequenceKeypoint.new(1,4.5,0)}); }; Children = {} },
    				{ ID = 48; Type = "ParticleEmitter"; Properties = { VelocitySpread = -360; Acceleration = Vector3.new(0,10,0); Texture = "rbxassetid://17086409913"; LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1/3,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1/3,1,1))}); Drag = 10; ZOffset = -2; SpreadAngle = Vector2.new(-360,360); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.10092400014400482,0,0),NumberSequenceKeypoint.new(1,0,0)}); Name = "Specs1"; Lifetime = NumberRange.new(0.75,1); Speed = NumberRange.new(25); Rate = 150; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.05000000074505806,0.05000000074505806),NumberSequenceKeypoint.new(0.30000001192092896,0.05000000074505806,0.05000000074505806),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    				{ ID = 49; Type = "ParticleEmitter"; Properties = { Acceleration = Vector3.new(0,15,0); RotSpeed = NumberRange.new(-300,300); VelocitySpread = -360; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(31/85,1,244/255)),ColorSequenceKeypoint.new(1,Color3.new(31/85,1,244/255))}); Drag = 7; ZOffset = 2; Texture = "rbxassetid://9470888178"; Rotation = NumberRange.new(-360,360); LightEmission = 1; Name = "Cubes"; Lifetime = NumberRange.new(1,1.5); Speed = NumberRange.new(45); SpreadAngle = Vector2.new(-360,360); LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.26100000739097595,0.10000000149011612,0.10000000149011612),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    				{ ID = 50; Type = "ParticleEmitter"; Properties = { VelocitySpread = -180; Acceleration = Vector3.new(0,10,0); Texture = "rbxassetid://6763809313"; LightEmission = 1; Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(58/255,1,72/85)),ColorSequenceKeypoint.new(1,Color3.new(58/255,1,72/85))}); Drag = 5; ZOffset = -1; SpreadAngle = Vector2.new(-180,180); Rotation = NumberRange.new(-90); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.25,0,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Specs2"; Lifetime = NumberRange.new(0.10000000149011612); Speed = NumberRange.new(100); Rate = 100; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.8749997615814209,0.8749997615814209),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    				{ ID = 51; Type = "ParticleEmitter"; Properties = { VelocitySpread = -360; RotSpeed = NumberRange.new(-35,35); Texture = "rbxassetid://10357918337"; LightEmission = 1; Drag = 4; ZOffset = 0.699999988079071; SpreadAngle = Vector2.new(-360,360); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2695560157299042,0.8812500238418579,0.018750011920928955),NumberSequenceKeypoint.new(1,1,0)}); Name = "Wind"; Lifetime = NumberRange.new(0.4000000059604645,0.6000000238418579); Speed = NumberRange.new(0.0010000000474974513); Rate = 15; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.28701457381248474,3.812499523162842,0),NumberSequenceKeypoint.new(0.4180825352668762,5.499999523162842,0),NumberSequenceKeypoint.new(0.5254854559898376,6.9375,0),NumberSequenceKeypoint.new(0.6930000185966492,6.940000057220459,0),NumberSequenceKeypoint.new(1,6.940000057220459,0)}); }; Children = {} },
    				{ ID = 52; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))}); Drag = 7; VelocitySpread = -360; Lifetime = NumberRange.new(0.75); Speed = NumberRange.new(25); Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5086107850074768,0.9375,0),NumberSequenceKeypoint.new(1,0,0)}); Acceleration = Vector3.new(0,15,0); RotSpeed = NumberRange.new(1,160); LockedToPart = true; Rate = 25; EmissionDirection = Enum.NormalId.Bottom; Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.05368097871541977,0,0),NumberSequenceKeypoint.new(0.9769938588142395,0,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "SnowFlake"; LightEmission = 1; Texture = "rbxassetid://8163218169"; Rotation = NumberRange.new(0,360); SpreadAngle = Vector2.new(-360,360); }; Children = {} },
    			}; },
    			{ ID = 53; Type = "ParticleEmitter"; Properties = { VelocitySpread = -1000; RotSpeed = NumberRange.new(-10,10); Texture = "rbxassetid://11941047152"; LightEmission = 1; Drag = 1; ZOffset = 5; SpreadAngle = Vector2.new(-1000,1000); Rotation = NumberRange.new(-1000,1000); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Snow"; Lifetime = NumberRange.new(2); Speed = NumberRange.new(0); Rate = 1; LockedToPart = true; Orientation = Enum.ParticleOrientation.VelocityPerpendicular; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,5,0),NumberSequenceKeypoint.new(1,5,0)}); }; Children = {} },
    				{ ID = 54; Type = "ParticleEmitter"; Properties = { Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,1,1)),ColorSequenceKeypoint.new(1,Color3.new(1,1,1))}); LockedToPart = true; ZOffset = 3; Texture = "rbxassetid://13768810492"; Name = "Stars"; Lifetime = NumberRange.new(0.20000000298023224,0.30000001192092896); Speed = NumberRange.new(0); LightEmission = 1; Rate = 5; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(0.5009999871253967,0.5,0.5),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
    		}; };
    	};
    };

    local function Scan(item, parent)
        local obj = Instance.new(item.Type)
        if (item.ID) then
            local awaiting = awaitRef[item.ID]
            if (awaiting) then
                awaiting[1][awaiting[2]] = obj
                awaitRef[item.ID] = nil
            else
                partsWithId[item.ID] = obj
            end
        end
        for p,v in pairs(item.Properties) do
            if (type(v) == "string") then
                local id = tonumber(v:match("^_R:(%w+)_$"))
                if (id) then
                    if (partsWithId[id]) then
                        v = partsWithId[id]
                    else
                        awaitRef[id] = {obj, p}
                        v = nil
                    end
                end
            end
            obj[p] = v
        end
        for _,c in pairs(item.Children) do
            Scan(c, obj)
        end
        obj.Parent = parent
        return obj
    end

    V.FrozenTemplate = Scan(root, nil)
    return V.FrozenTemplate
end

function V.CreateFrozenAura(char)
    if not char then return end
    local template = V._GetFrozenTemplate()
    if not template then return end

    local function findPart(charModel, names)
        for i=1,#names do
            local p = charModel:FindFirstChild(names[i])
            if p then return p end
        end
        return nil
    end
    local function getAttachOrPart(partNames, attachNames)
        local part = findPart(char, partNames)
        if part then
            for i=1,#attachNames do
                local a = part:FindFirstChild(attachNames[i])
                if a then return a end
            end
            return part
        end
        return nil
    end
    local function addAllFrom(node, target)
        if not node or not target then return end
        for _,d in ipairs(node:GetDescendants()) do
            if d:IsA('ParticleEmitter') then
                local pe = d:Clone()
                pe.Parent = target
                table.insert(V.AuraEmitters, pe)
            end
        end
    end

    local tHead = template:FindFirstChild('Head')
    local tLArm = template:FindFirstChild('Left Arm')
    local tRArm = template:FindFirstChild('Right Arm')
    local tLLeg = template:FindFirstChild('Left Leg')
    local tRLeg = template:FindFirstChild('Right Leg')
    local tTorso = template:FindFirstChild('Torso')

    addAllFrom(tHead, getAttachOrPart({'Head'},{'HatAttachment','FaceCenterAttachment'}))
    addAllFrom(tLArm, getAttachOrPart({'LeftUpperArm','Left Arm'},{'LeftShoulderRigAttachment','LeftShoulderAttachment'}))
    addAllFrom(tRArm, getAttachOrPart({'RightUpperArm','Right Arm'},{'RightShoulderRigAttachment','RightShoulderAttachment'}))
    addAllFrom(tLLeg, getAttachOrPart({'LeftFoot','Left Leg'},{'LeftFootAttachment'}))
    addAllFrom(tRLeg, getAttachOrPart({'RightFoot','Right Leg'},{'RightFootAttachment'}))
    addAllFrom(tTorso, getAttachOrPart({'UpperTorso','Torso'},{'WaistCenterAttachment','BodyBackAttachment'}))
end

local function IsPlayerKO(player)
    return player and player.Character and player.Character:FindFirstChild("BodyEffects") and 
           player.Character.BodyEffects:FindFirstChild("K.O") and player.Character.BodyEffects["K.O"].Value
end

local function IsPlayerGrabbed(player)
    return player and player.Character and player.Character:FindFirstChild("BodyEffects") and 
           player.Character.BodyEffects:FindFirstChild("Grabbed") and player.Character.BodyEffects.Grabbed.Value
end

local function GetClosestPlayerToCursor()
    local closestPlayer, shortestDistance = nil, V.math.huge
    
    -- Кешируем позицию мыши один раз
    V.MouseLocation = V.UIS:GetMouseLocation()

    for _, player in ipairs(V.Players:GetPlayers()) do
        if player ~= V.LP and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            V.ScreenPoint, V.OnScreen = V.Cam:WorldToViewportPoint(player.Character.HumanoidRootPart.Position)
            if V.OnScreen then
                local distance = (V.V2(V.ScreenPoint.X, V.ScreenPoint.Y) - V.V2(V.MouseLocation.X, V.MouseLocation.Y)).Magnitude
                if (not Config.Aimbot.SkipCovered or IsVisible(player.Character.HumanoidRootPart))
                    and (not Config.Aimbot.SkipKnocked or not IsPlayerKO(player))
                    and (not Config.Aimbot.SkipGrabbed or not IsPlayerGrabbed(player))
                    and distance < shortestDistance then
                    shortestDistance, closestPlayer = distance, player
                end
            end
        end
    end
    return closestPlayer
end

-----------------------
-- TARGET HIGHLIGHT FUNCTIONS
-----------------------

local function CreateTargetHighlight(character)
    if not character then return nil end
    
    -- уменьшаем количество локалов: используем временный кэш в V и очищаем
    V.TempHighlight = Instance.new('Highlight')
    V.TempHighlight.Parent = character
    V.TempHighlight.OutlineColor = Config.TargetHighlight.OutlineColor
    V.TempHighlight.FillColor = Config.TargetHighlight.FillColor
    V.TempHighlight.OutlineTransparency = Config.TargetHighlight.OutlineTransparency
    V.TempHighlight.FillTransparency = Config.TargetHighlight.FillTransparency
    V.TempHighlight.Adornee = character

    local ret = V.TempHighlight
    V.TempHighlight = nil
    return ret
end

-- UpdateViewTarget теперь пустая функция-заглушка
local function UpdateViewTarget() end


local function UpdateTargetHighlight()
    -- Быстрая проверка: если хайлайт отключен
    if not Config.TargetHighlight.Enabled then
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
            V.LastHighlightTarget = nil
        end
        return
    end
    
    V.Temp.Character = V.Target and V.Target.character
    
    -- Проверяем, изменилась ли цель
    if V.Temp.Character ~= V.LastHighlightTarget then
        -- Удаляем старый хайлайт
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
        
        -- Создаем новый хайлайт только если есть валидная цель
        if V.Temp.Character and V.Temp.Character.Parent then
            V.CurrentHighlight = CreateTargetHighlight(V.Temp.Character)
            -- Обновляем кэш конфигурации
            V.LastHighlightConfig.OutlineColor = Config.TargetHighlight.OutlineColor
            V.LastHighlightConfig.FillColor = Config.TargetHighlight.FillColor
            V.LastHighlightConfig.OutlineTransparency = Config.TargetHighlight.OutlineTransparency
            V.LastHighlightConfig.FillTransparency = Config.TargetHighlight.FillTransparency
        end
        
        V.LastHighlightTarget = V.Temp.Character
        return
    end
    
    -- Проверяем, изменилась ли конфигурация (только если есть хайлайт)
    if V.CurrentHighlight and V.Temp.Character and V.Temp.Character.Parent then
        -- Обновляем свойства только если они изменились
        local configChanged = false
        
        if V.LastHighlightConfig.OutlineColor ~= Config.TargetHighlight.OutlineColor then
            V.CurrentHighlight.OutlineColor = Config.TargetHighlight.OutlineColor
            V.LastHighlightConfig.OutlineColor = Config.TargetHighlight.OutlineColor
            configChanged = true
        end
        
        if V.LastHighlightConfig.FillColor ~= Config.TargetHighlight.FillColor then
            V.CurrentHighlight.FillColor = Config.TargetHighlight.FillColor
            V.LastHighlightConfig.FillColor = Config.TargetHighlight.FillColor
            configChanged = true
        end
        
        if V.LastHighlightConfig.OutlineTransparency ~= Config.TargetHighlight.OutlineTransparency then
            V.CurrentHighlight.OutlineTransparency = Config.TargetHighlight.OutlineTransparency
            V.LastHighlightConfig.OutlineTransparency = Config.TargetHighlight.OutlineTransparency
            configChanged = true
        end
        
        if V.LastHighlightConfig.FillTransparency ~= Config.TargetHighlight.FillTransparency then
            V.CurrentHighlight.FillTransparency = Config.TargetHighlight.FillTransparency
            V.LastHighlightConfig.FillTransparency = Config.TargetHighlight.FillTransparency
            configChanged = true
        end
    else
        -- Цель потеряна, удаляем хайлайт
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
        V.LastHighlightTarget = nil
    end
end

-----------------------
-- GUNEXPLOIT FUNCTIONS
-----------------------

local function EquipRevolver()
    V.CurrentWeapon = (function()
        local w = V.LP.Character and V.LP.Character:FindFirstChild("[Revolver]")
        if w then return w end
        w = V.LP.Backpack and V.LP.Backpack:FindFirstChild("[Revolver]")
        return w and (function() w.Parent = V.LP.Character; return w end)() or nil
    end)()
    return V.CurrentWeapon ~= nil
end

local function SetupRapidFire()
    if V.RapidFireConnection then V.RapidFireConnection:Disconnect() end
    V.LastRapidFireUpdate = 0
    
    V.RapidFireConnection = V.RS.Heartbeat:Connect(function()
        -- Увеличиваем интервал проверки до 20 раз в секунду (каждые 0.05 сек)
        local now = os.clock()
        if now - V.LastRapidFireUpdate < 0.05 then return end
        V.LastRapidFireUpdate = now
        
        -- Проверяем оружие только если оно изменилось
        local tool = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Tool")
        if not tool or not tool:FindFirstChild("GunScript") then return end
        
        -- Оптимизированный rapid fire с проверкой на ошибки
        pcall(function()
            for _, conn in ipairs(getconnections(tool.Activated)) do
                if conn and conn.Function then
                    -- Кэшируем функцию, чтобы не вызывать getinfo лишний раз
                    local func = conn.Function
                    for i = 1, debug.info(func, 'u') do
                        -- Проверяем только числовые upvalues
                        local name, value = debug.getupvalue(func, i)
                        if type(value) == "number" and name and name:lower():find("delay") then
                            debug.setupvalue(func, i, 0.000001)
                        end
                    end
                end
            end
        end)
    end)
end

local function SetupAutoReload()
    if V.AutoReloadConnection then V.AutoReloadConnection:Disconnect() end
    V.LastAutoReloadCheck = 0
    V.AutoReloadConnection = V.RS.Heartbeat:Connect(function()
        -- Ограничиваем проверки до 10 раз в секунду (каждые 0.1 сек)
        V.FuncCache.CurrentTime = os.clock()
        if V.FuncCache.CurrentTime - V.LastAutoReloadCheck < 0.1 then return end
        V.LastAutoReloadCheck = V.FuncCache.CurrentTime
        
        -- Проверяем только если у нас есть оружие в руках
        V.WeaponCache.Tool = V.LP.Character and V.LP.Character:FindFirstChildWhichIsA("Tool")
        if not V.WeaponCache.Tool or not V.WeaponCache.Tool:FindFirstChild("Ammo") then return end
        
        -- Проверяем патроны только если прошло больше 1 секунды с последней перезарядки
        if V.WeaponCache.Tool.Ammo.Value > 0 then return end
        if V.FuncCache.CurrentTime - V.LastReload < 1 then return end
        
        V.LastReload = V.FuncCache.CurrentTime
        -- Меняем слот, чтобы перезарядить оружие
        V.ReplicatedStorage.MainEvent:FireServer("ChangeLoadout", "[Knife]", "Slot3")
    end)
end

local function SetupCharacterMonitoring(character)
    -- Отключаем старые соединения, если они есть
    if V.GunExploitAddedConn then V.GunExploitAddedConn:Disconnect() end
    if V.GunExploitRemovedConn then V.GunExploitRemovedConn:Disconnect() end
    
    -- Мониторинг добавления оружия
    V.GunExploitAddedConn = character.ChildAdded:Connect(function(child)
        if not V.GunExploitActive then return end
        -- Проверяем только инструменты с GunScript
        if child:IsA("Tool") and child:FindFirstChild("GunScript") then
            V.CurrentWeapon = child
            -- Запускаем rapid fire и авто-перезарядку только после успешного экипирования
            SetupRapidFire()
            SetupAutoReload()
        end
    end)
    
    -- Мониторинг удаления оружия
    V.GunExploitRemovedConn = character.ChildRemoved:Connect(function(child)
        if not V.GunExploitActive then return end
        if child == V.CurrentWeapon then
            -- Отключаем rapid fire при потере оружия
            if V.RapidFireConnection then 
                V.RapidFireConnection:Disconnect() 
                V.RapidFireConnection = nil 
            end
            V.CurrentWeapon = nil
            
            -- Пробуем переэкипировать с задержкой
            delay(0.2, function()
                if V.GunExploitActive and V.LP.Character then
                    EquipRevolver()
                end
            end)
        end
    end)
end

local function StartGunExploit()
    if V.GunExploitActive then return end
    V.GunExploitActive = true
    
    -- Обработчик респавна персонажа
    if not V.CharacterAddedConnection then
        V.CharacterAddedConnection = V.LP.CharacterAdded:Connect(function(character)
            if not V.GunExploitActive then return end
            -- Даем время на загрузку персонажа
            delay(0.5, function()
                if V.GunExploitActive then
                    SetupCharacterMonitoring(character)
                    EquipRevolver()
                end
            end)
        end)
    end
    
    -- Инициализация для текущего персонажа
    if V.LP.Character then
        SetupCharacterMonitoring(V.LP.Character)
        EquipRevolver()
    end
end

local function StopGunExploit()
    V.GunExploitActive = false
    
    -- Disconnect connections
    if V.RapidFireConnection then
        V.RapidFireConnection:Disconnect()
        V.RapidFireConnection = nil
    end
    
    if V.AutoReloadConnection then
        V.AutoReloadConnection:Disconnect()
        V.AutoReloadConnection = nil
    end

    -- Отключаем все соединения
    if V.GunExploitAddedConn then V.GunExploitAddedConn:Disconnect(); V.GunExploitAddedConn = nil end
    if V.GunExploitRemovedConn then V.GunExploitRemovedConn:Disconnect(); V.GunExploitRemovedConn = nil end
    if V.CharacterAddedConnection then V.CharacterAddedConnection:Disconnect(); V.CharacterAddedConnection = nil end
    
    -- Remove weapon from hands
    if V.CurrentWeapon and V.CurrentWeapon.Parent == V.LP.Character then
        V.CurrentWeapon.Parent = V.LP.Backpack
    end
    V.CurrentWeapon = nil
end

-----------------------
-- BULLET TRACERS SYSTEM
-----------------------

local function CreateDrawingTracer(startPos, endPos)
    table.insert(V.ActiveTracers, {
        type = "Drawing",
        line = (function()
            V.Temp.Line = Drawing.new("Line")
            V.Temp.Line.Color, V.Temp.Line.Thickness, V.Temp.Line.Transparency, V.Temp.Line.Visible = Config.BulletTracers.Color, Config.BulletTracers.Thickness, 1, true
            return V.Temp.Line
        end)(),
        circle = (function()
            V.Temp.TempCircle = Drawing.new("Circle")
            V.Temp.TempCircle.Color, V.Temp.TempCircle.Thickness, V.Temp.TempCircle.Radius, V.Temp.TempCircle.Filled, V.Temp.TempCircle.Transparency, V.Temp.TempCircle.Visible = Config.BulletTracers.Color, Config.BulletTracers.Thickness, 4, false, 1, true
            return V.Temp.TempCircle
        end)(),
        startPos = startPos,
        endPos = endPos,
        startTime = tick(),
        duration = Config.BulletTracers.Duration
    })
end

local function CreateBeamTracer(startPos, endPos)
    -- Создаем невидимую основную часть (временные переменные через V, затем очищаем)
    V.TempMainPart = Instance.new("Part")
    V.TempMainPart.Name = "BulletTracer"
    V.TempMainPart.Parent = V.WS
    V.TempMainPart.Size = V.BeamTracerSize
    V.TempMainPart.Massless = true
    V.TempMainPart.Transparency = 1
    V.TempMainPart.CanCollide = false
    V.TempMainPart.Position = startPos
    V.TempMainPart.Anchored = true

    -- Создаем две точки для луча
    V.TempPart0 = Instance.new("Part")
    V.TempPart0.Parent = V.TempMainPart
    V.TempPart0.Size = V.BeamTracerSize
    V.TempPart0.Massless = true
    V.TempPart0.Transparency = 1
    V.TempPart0.CanCollide = false
    V.TempPart0.Position = startPos
    V.TempPart0.Anchored = true

    V.TempPart1 = Instance.new("Part")
    V.TempPart1.Parent = V.TempMainPart
    V.TempPart1.Size = V.BeamTracerSize
    V.TempPart1.Massless = true
    V.TempPart1.Transparency = 1
    V.TempPart1.CanCollide = false
    V.TempPart1.Position = endPos
    V.TempPart1.Anchored = true

    -- Создаем точки крепления для луча
    V.TempAttach0 = Instance.new("Attachment")
    V.TempAttach0.Parent = V.TempPart0

    V.TempAttach1 = Instance.new("Attachment")
    V.TempAttach1.Parent = V.TempPart1

    -- Создаем сам луч
    V.TempBeam = Instance.new("Beam")
    V.TempBeam.Texture = "rbxassetid://7216850022"
    V.TempBeam.TextureMode = Enum.TextureMode.Wrap
    V.TempBeam.TextureLength = 10
    V.TempBeam.LightEmission = 1
    V.TempBeam.LightInfluence = 1
    V.TempBeam.FaceCamera = true
    V.TempBeam.ZOffset = -1
    V.TempBeam.Width0 = Config.BulletTracers.Thickness
    V.TempBeam.Width1 = Config.BulletTracers.Thickness
    V.TempBeam.Transparency = NumberSequence.new(0)
    V.TempBeam.Color = ColorSequence.new(Config.BulletTracers.Color)
    V.TempBeam.Attachment0 = V.TempAttach0
    V.TempBeam.Attachment1 = V.TempAttach1
    V.TempBeam.Enabled = true
    V.TempBeam.Parent = V.TempMainPart

    table.insert(V.ActiveTracers, {
        type = "Beam",
        mainPart = V.TempMainPart,
        beam = V.TempBeam,
        startTime = tick(),
        duration = Config.BulletTracers.Duration
    })

    -- очистка временных ссылок
    V.TempBeam = nil
    V.TempAttach0 = nil
    V.TempAttach1 = nil
    V.TempPart0 = nil
    V.TempPart1 = nil
    V.TempMainPart = nil
end

local function CreateTracer(startPos, endPos)
    if not Config.BulletTracers.Enabled then return end
    
    if Config.BulletTracers.Mode == "Drawing" then
        CreateDrawingTracer(startPos, endPos)
    elseif Config.BulletTracers.Mode == "Texture" then
        CreateBeamTracer(startPos, endPos)
    end
end

local function UpdateBulletTracers()
    if not Config.BulletTracers.Enabled or not V.ActiveTracers then return end
    
    for i = #V.ActiveTracers, 1, -1 do
        local t = V.ActiveTracers[i]
        local elapsed = tick() - t.startTime
        
        if elapsed >= t.duration then
            -- Очистка в зависимости от типа
            if t.type == "Drawing" then
                t.line:Remove(); if t.circle then t.circle:Remove() end
            elseif t.type == "Beam" then
                t.mainPart:Destroy()
            end
            table.remove(V.ActiveTracers, i)
        else
            if t.type == "Drawing" then
                local startScreen, startOn = V.Cam:WorldToViewportPoint(t.startPos)
                local endScreen, endOn = V.Cam:WorldToViewportPoint(t.endPos)
                
                if startOn and endOn then
                    t.line.From, t.line.To, t.line.Visible = V.V2(startScreen.X, startScreen.Y), V.V2(endScreen.X, endScreen.Y), true
                    if t.circle then t.circle.Position, t.circle.Visible = V.V2(endScreen.X, endScreen.Y), true end
                    
                    local alpha = elapsed >= (t.duration - 0.1) and (1 - ((elapsed - (t.duration - 0.1)) / 0.1)) or 1
                    t.line.Transparency = alpha
                    if t.circle then t.circle.Transparency = alpha end
                else
                    t.line.Visible = false
                    if t.circle then t.circle.Visible = false end
                end
            elseif t.type == "Beam" then
                -- Эффект затухания для beam
                local alpha = elapsed >= (t.duration - 0.1) and (1 - ((elapsed - (t.duration - 0.1)) / 0.1)) or 1
                if t.beam and t.beam.Parent then
                    t.beam.Transparency = NumberSequence.new(1 - alpha)
                end
            end
        end
    end
end

local function InitBulletTracers()
    if V.BulletTracerConnection then
        V.BulletTracerConnection:Disconnect()
    end
    
    V.BulletTracerConnection = V.WS.Ignored.ChildAdded:Connect(function(Object)
        if Object.Name == "BULLET_RAYS" then
            local ownerCharacterName = Object:GetAttribute("OwnerCharacter")
            if ownerCharacterName and ownerCharacterName == V.LP.Name then
                local startPos = Object.CFrame.Position
                local lookVector = Object.CFrame.LookVector

                -- Используем кешированный RaycastParams
                if not V.BulletRaycastParams then
                    V.BulletRaycastParams = RaycastParams.new()
                    V.BulletRaycastParams.FilterType = Enum.RaycastFilterType.Exclude
                    V.BulletRaycastParams.IgnoreWater = true
                end
                V.BulletRaycastParams.FilterDescendantsInstances = {V.LP.Character}

                local ray = V.WS:Raycast(startPos, lookVector * 1000, V.BulletRaycastParams)
                if ray then
                    CreateTracer(startPos, ray.Position)
                end
            end
        end
    end)
end

local function CleanupBulletTracers()
    if V.BulletTracerConnection then V.BulletTracerConnection:Disconnect(); V.BulletTracerConnection = nil end
    if V.ActiveTracers then
        for _, t in pairs(V.ActiveTracers) do
            if t.type == "Drawing" then
                t.line:Remove(); if t.circle then t.circle:Remove() end
            elseif t.type == "Beam" then
                t.mainPart:Destroy()
            end
        end
        V.ActiveTracers = {}
    end
end

-----------------------
-- AIMBOT PREDICTION & RESOLVER
-----------------------


local function GetPredictedPosition(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then return nil end

    if not (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")) then return nil end
    
    if not V.LastPosition or not V.LastUpdateTime then
        V.LastPosition = (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position
        V.LastUpdateTime = tick()
        return V.LastPosition
    end

    if Config.Aimbot.ResolverMode == "Velocity" then
        return (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position + V.V3(
            (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Velocity.X * Config.Aimbot.Prediction,
            (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Velocity.Y * Config.Aimbot.Prediction,
            (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Velocity.Z * Config.Aimbot.Prediction
        )
    elseif Config.Aimbot.ResolverMode == "MoveDirection" then
        return (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position + (targetPlayer.Character.Humanoid.MoveDirection * (Config.Aimbot.Prediction * 10))
    elseif Config.Aimbot.ResolverMode == "CalculateCFrame" then
        if ((targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position - V.LastPosition).Magnitude < 0.001 then
            return (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position
        else
            V.LastUpdateTime, V.LastPosition = tick(), (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position
            return V.LastPosition + (V.LastPosition - V.LastPosition).Unit * ((((V.LastPosition - V.LastPosition).Magnitude) / (tick() - V.LastUpdateTime)) * (0.1 * (Config.Aimbot.Prediction * 10))) + V.V3(0, ((V.LastPosition.Y - V.LastPosition.Y) / (tick() - V.LastUpdateTime) * (0.1 * Config.Aimbot.Prediction)), 0)
        end
    end
    return (targetPlayer.Character:FindFirstChild(Config.Aimbot.SelectedPart) or targetPlayer.Character:FindFirstChild("HumanoidRootPart")).Position
end

local function Check()
    return Config.Aimbot.AimbotEnabled and V.Target and V.Target.player and V.Target.character
end

-----------------------
-- CSYNC SYSTEM
-----------------------

local function GetRandomPositionAroundTarget(targetRoot)
    return targetRoot.Position + V.V3(
        V.math.random(-(Config.Aimbot.CSyncRange or 10), (Config.Aimbot.CSyncRange or 10)),
        V.math.random(-(Config.Aimbot.CSyncHeight or 5), (Config.Aimbot.CSyncHeight or 5)),
        V.math.random(-(Config.Aimbot.CSyncRange or 10), (Config.Aimbot.CSyncRange or 10))
    )
end

local function StartCSync()
    if V.CSyncConnection then
        V.CSyncConnection:Disconnect()
        V.CSyncConnection = nil
    end
    
    if not Config.Aimbot.CSyncEnabled or not V.Target or not V.Target.character or (V.AutoStompState and V.AutoStompState.blockedTargets and V.AutoStompState.blockedTargets[V.Target.player]) then
        return
    end
    
    print('[CSync] Запуск C-Sync')
    
    V.CSyncConnection = V.RS.Heartbeat:Connect(function()
        local clientRoot = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
        local targetRoot = V.Target and V.Target.character and V.Target.character:FindFirstChild("HumanoidRootPart")
        
        if not clientRoot or not targetRoot then
            return
        end
        
        -- Дополнительная проверка что clientRoot все еще валиден
        if not clientRoot.Parent then
            return
        end
        
        -- Сохраняем реальную позицию
        V.SavedDesync = clientRoot.CFrame
        
        -- Генерируем случайную позицию вокруг цели
        V.StrafeCFrame = GetRandomPositionAroundTarget(targetRoot)
        
        -- Проверяем что StrafeCFrame валиден
        if not V.StrafeCFrame then
            return
        end
        
        -- Телепорт на стрейф-позицию с проверкой
        if clientRoot and clientRoot.Parent then
            clientRoot.CFrame = typeof(V.StrafeCFrame) == "CFrame" and V.StrafeCFrame or V.CF(V.StrafeCFrame)
        end
        
        -- Ожидаем кадр
        V.RS.RenderStepped:Wait()
        
        -- Возвращаемся на реальную позицию с проверкой
        if clientRoot and clientRoot.Parent and V.SavedDesync then
            clientRoot.CFrame = V.SavedDesync
        end
    end)
end

local function StopCSync()
    if V.CSyncConnection then
        print('[CSync] Остановка C-Sync')
        V.CSyncConnection:Disconnect()
        V.CSyncConnection = nil
    end
    
    -- Возвращаем игрока на реальную позицию перед остановкой
    local clientRoot = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
    if clientRoot and clientRoot.Parent and V.SavedDesync then
        clientRoot.CFrame = V.SavedDesync
        print('[CSync] Позиция игрока восстановлена')
    end
    
    V.SavedDesync = nil
    V.StrafeCFrame = nil
end

-- DESYNC TELEPORT HELPER
local function DesyncTeleport(targetCF)
    -- Телепорт на сервер (Heartbeat), возврат для клиента (RenderStepped)
    local root = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
    if not root or not root.Parent then return end
    local originalCF = root.CFrame

    -- Создаём одноразовое соединение Heartbeat -> RenderStepped
    local hbConn; hbConn = V.RS.Heartbeat:Connect(function()
        hbConn:Disconnect()
        if not root or not root.Parent then return end
        root.CFrame = targetCF -- перемещаемся для сервера

        -- После телепорта немедленно возвращаем позицию до рендера кадра
        local rsConn; rsConn = V.RS.RenderStepped:Connect(function()
            rsConn:Disconnect()
            if root and root.Parent then
                root.CFrame = originalCF -- возвращаем локальному клиенту
            end
        end)
    end)
end

-- AUTOSTOMP SYSTEM
-- V.AutoStompState теперь в таблице V для оптимизации

-- Функция для проверки, проигрывается ли звук смерти у цели
local function IsDeathSoundPlaying(character)
    if not character then return false end
    
    -- Проверяем все Sound в модели персонажа
    for _, child in ipairs(character:GetDescendants()) do
        if child:IsA("Sound") and child.IsPlaying and child.SoundId == V.AutoStompState.soundId then
            return true
        end
    end
    return false
end

-- Вспомогательная функция для массового включения/выключения коллизии у персонажа
local function ZeroCharacterVelocity(char)
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.AssemblyLinearVelocity = V.V3(0,0,0)
            part.AssemblyAngularVelocity = V.V3(0,0,0)
        end
    end
end

-- Вспомогательная функция для массового включения/выключения коллизии у персонажа
local function SetCharacterCollision(char, state)
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = state
        end
    end
end

local function GetRagdollPart(character)
    if not character then return nil end
    for _, partName in ipairs({"UpperTorso","LowerTorso"}) do
        V.Temp.Part = character:FindFirstChild(partName)
        if V.Temp.Part then return V.Temp.Part end
    end
    return character:FindFirstChild("HumanoidRootPart")
end

local function CreateAutoStompFollowPart()
    if V.AutoStompState.followPart and V.AutoStompState.followPart.Parent then V.AutoStompState.followPart:Destroy() end
    
    V.AutoStompState.followPart = (function()
        V.InstCache.TempPart = Instance.new("Part")
        V.InstCache.TempPart.Name, V.InstCache.TempPart.Anchored, V.InstCache.TempPart.CanCollide, V.InstCache.TempPart.Size, V.InstCache.TempPart.Transparency, V.InstCache.TempPart.Parent = "AutoStompFollowPart", true, false, V.V3(0.1,0.1,0.1), 1, V.WS
        if V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart") then
            V.InstCache.TempPart.CFrame = V.CF((V.LP.Character:FindFirstChild("HumanoidRootPart")).Position + V.V3(0, 1.58, 0))
        end
        return V.InstCache.TempPart
    end)()
    
    return V.AutoStompState.followPart
end

local function ResetAutoStompCamera()
    -- Очищаем блокировку для несуществующих или живых целей
    for player, _ in pairs(V.AutoStompState.blockedTargets) do
        if not player.Parent or not IsPlayerKO(player) then
            V.AutoStompState.blockedTargets[player] = nil
        end
    end
    
    -- Если камера была привязана к followPart, вернем её на Humanoid ДО удаления followPart,
    -- чтобы избежать залипания/заморозки камеры независимо от состояния CSync/ViewTarget
    do
        local lhum = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Humanoid")
        if lhum and V.AutoStompState.followPart and V.Cam.CameraSubject == V.AutoStompState.followPart then
            V.Cam.CameraSubject = lhum
        end
    end
    if V.AutoStompState.followPart and V.AutoStompState.followPart.Parent then
        V.AutoStompState.followPart:Destroy()
    end
    V.AutoStompState.followPart = nil
    -- Возвращаем коллизии, если они были отключены
    if V.AutoStompState.collisionDisabled then
        if V.AutoStompState.targetPlayer and V.AutoStompState.targetPlayer.Character then
            SetCharacterCollision(V.AutoStompState.targetPlayer.Character, true)
        end
        V.AutoStompState.collisionDisabled = nil
        V.AutoStompState.targetPlayer = nil
    end
    -- Возобновляем CSync, если он был приостановлен
    if V.AutoStompState.csyncPaused then
        V.AutoStompState.csyncPaused = nil
        if Config.Aimbot.CSyncEnabled then
            StartCSync()
        end
    end
    -- Возобновляем Hide, если он был приостановлен
    if V.AutoStompState.hidePaused then
        V.AutoStompState.hidePaused = nil
        if Config.Hide.Enabled then
            StartHide()
        end
    end
    -- Дополнительно: если камера всё ещё указывает на несуществующий объект, вернём на Humanoid
    do
        local lhum = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Humanoid")
        if lhum and (not V.Cam.CameraSubject or (typeof(V.Cam.CameraSubject) == "Instance" and not V.Cam.CameraSubject.Parent)) then
            V.Cam.CameraSubject = lhum
        end
    end
end

local function PerformStomp()
    local mainEvent = V.RSStorage:FindFirstChild("MainEvent")
    if mainEvent then
        mainEvent:FireServer("Stomp")
    end
    V.AutoStompState.lastTime = tick()
end

local function ApplyAutoStomp()
    -- Если Hide включен, не запускаем AutoStomp (конфликт систем)
    if Config.Hide and Config.Hide.Enabled then
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return
    end
    
    -- Если игрок двигается сам, отключаем AutoStomp чтобы не мешать управлению
    local lhumMove = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Humanoid") and V.LP.Character:FindFirstChildOfClass("Humanoid").MoveDirection
    if lhumMove and lhumMove.Magnitude > 0.1 then
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return
    end

    if not Config.Aimbot.AutoStompEnabled then
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return
    end
    if not V.Target or not V.Target.player then return end
    local targetPlayer = V.Target.player
    if not IsPlayerKO(targetPlayer) then
        if V.AutoStompState.blockedTargets[targetPlayer] and not IsPlayerKO(targetPlayer) then
            V.AutoStompState.blockedTargets[targetPlayer] = nil
        end
        -- Если цель больше не в нокауте, корректно завершим AutoStomp и вернем Hide
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return 
    end
    local ragdollPart = GetRagdollPart(targetPlayer.Character)
    if not ragdollPart then 
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return 
    end

    local hrp = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then 
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return 
    end

    -- Блокируем AutoStomp, если Hide активен
    if Config.Hide and Config.Hide.Enabled then
        if V.AutoStompState.active then
            V.AutoStompState.active = false
            ResetAutoStompCamera()
        end
        return
    end

    if not V.AutoStompState.active then
        -- При старте AutoStomp приостанавливаем CSync, если он активен
        if Config.Aimbot.CSyncEnabled and V.CSyncConnection then
            StopCSync()
            V.AutoStompState.csyncPaused = true
        end
        -- Hide больше не приостанавливаем: AutoStomp не работает при активном Hide
        V.AutoStompState.active = true
        -- Отключаем коллизии только у цели
        SetCharacterCollision(targetPlayer.Character, false)
        V.AutoStompState.collisionDisabled = true
        V.AutoStompState.targetPlayer = targetPlayer

        -- Устанавливаем delayStart так, чтобы проверка задержки сразу проходила, если DelayBeforeStomp == 0
        V.AutoStompState.delayStart = tick() - (Config.Aimbot.DelayBeforeStomp or 0)
        V.AutoStompState.lastTime = 0
        CreateAutoStompFollowPart()
    end

    if tick() - V.AutoStompState.delayStart < (Config.Aimbot.DelayBeforeStomp or 0.25) then
        return
    end


    -- Переключаем камеру на скрытую FollowPart, чтобы локально не дёргалось
    if V.AutoStompState.followPart then
        V.AutoStompState.followPart.CFrame = CFrame.new(hrp.Position + V.V3(0, 1.58, 0))
        V.Cam.CameraSubject = V.AutoStompState.followPart
    end

    -- Выполняем десинхронный телепорт к цели
    DesyncTeleport(CFrame.new(ragdollPart.Position + V.V3(0, (Config.Aimbot.YOffset or 2), 0)))
    -- Сброс скоростей, чтобы не флинговать
    ZeroCharacterVelocity(targetPlayer.Character)



    if tick() - V.AutoStompState.lastTime >= (Config.Aimbot.StompInterval or 0.4) then
        PerformStomp()
    end
end






local function StartMagicBullets()
    -- При активации MagicBullets останавливаем Hide, т.к. большая дистанция мешает стрельбе
    if Config.Hide and Config.Hide.Enabled and V.HideConnection and typeof(DisableHide) == "function" then
        DisableHide()
        V.HideWasPausedByMB = true
    end
    if V.MagicBulletConnection then return end
    V.MagicBulletConnection = V.RS.Heartbeat:Connect(function()
        if not (Config.Aimbot.MagicBullets and V.Target and V.Target.player) then return end

        -- Цель
        ShootAtPlayer(V.Target.player)

        -- Если цель захватили – стреляем и по грабберу
        local grabbedVal = V.Target.player.Character and V.Target.player.Character:FindFirstChild("BodyEffects") and V.Target.player.Character.BodyEffects:FindFirstChild("Grabbed")
        if grabbedVal and grabbedVal.Value and grabbedVal.Value.Parent then
            local grabberPlayer = V.Players:GetPlayerFromCharacter(grabbedVal.Value.Parent)
            if grabberPlayer then
                ShootAtPlayer(grabberPlayer)
            end
        end
    end)
end

local function StopMagicBullets()
    -- При остановке MagicBullets возвращаем Hide, если мы его приостанавливали
    if V.HideWasPausedByMB and typeof(EnableHide) == "function" then
        V.HideWasPausedByMB = nil
        if Config.Hide and Config.Hide.Enabled then EnableHide() end
    end
    if V.MagicBulletConnection then
        V.MagicBulletConnection:Disconnect()
        V.MagicBulletConnection = nil
    end
end

local function CreateCSyncVisualization(position)
    if not Config.Aimbot.CSyncVisualize then return end
    
    V.Temp.CSyncBillboard = Instance.new("BillboardGui")
    V.Temp.CSyncBillboard.Name = "CSyncVis"
    V.Temp.CSyncBillboard.Size = UDim2.new(2, 0, 2, 0)
    V.Temp.CSyncBillboard.AlwaysOnTop = true
    
    V.Temp.CSyncImage = Instance.new("ImageLabel", V.Temp.CSyncBillboard)
    V.Temp.CSyncImage.Name = "img3"
    V.Temp.CSyncImage.Size = UDim2.new(0.6, 0, 0.6, 0)
    V.Temp.CSyncImage.BackgroundTransparency = 1
    V.Temp.CSyncImage.Image = "rbxassetid://108770683919433"
    V.Temp.CSyncImage.ImageTransparency = 0
    V.Temp.CSyncImage.ImageColor3 = Config.Aimbot.CSyncVisualizeColor
    
    V.Temp.CSyncPart = Instance.new("Part")
    V.Temp.CSyncPart.Size = V.V3(0, 0, 0)
    V.Temp.CSyncPart.Anchored = true
    V.Temp.CSyncPart.Transparency = 1
    V.Temp.CSyncPart.CanCollide = false
    V.Temp.CSyncPart.Position = position
    V.Temp.CSyncPart.Parent = V.WS
    
    V.Temp.CSyncBillboard.Adornee = V.Temp.CSyncPart
    V.Temp.CSyncBillboard.Parent = V.WS
    
    return {gui = V.Temp.CSyncBillboard, part = V.Temp.CSyncPart}
end

local function UpdateCSyncVisualization()
    if not Config.Aimbot.CSyncVisualize then
        if V.CSyncVisualization then
            if V.CSyncVisualization.gui then V.CSyncVisualization.gui:Destroy() end
            if V.CSyncVisualization.part then V.CSyncVisualization.part:Destroy() end
            V.CSyncVisualization = nil
        end
        return
    end
    
    -- Показываем визуализацию только если CSync активен и есть позиция десинка
    if not Config.Aimbot.CSyncEnabled or not V.StrafeCFrame then
        if V.CSyncVisualization then
            if V.CSyncVisualization.gui then V.CSyncVisualization.gui:Destroy() end
            if V.CSyncVisualization.part then V.CSyncVisualization.part:Destroy() end
            V.CSyncVisualization = nil
        end
        return
    end
    
    if not V.CSyncVisualization then
        V.Temp.TempVector3 = typeof(V.StrafeCFrame) == "CFrame" and V.StrafeCFrame.Position or V.StrafeCFrame
        V.CSyncVisualization = CreateCSyncVisualization(V.Temp.TempVector3)
    end
    
    if V.CSyncVisualization and V.CSyncVisualization.part then
        -- Обновляем позицию визуализации на координаты CSync десинка
        V.Temp.TempVector3 = typeof(V.StrafeCFrame) == "CFrame" and V.StrafeCFrame.Position or V.StrafeCFrame
        V.CSyncVisualization.part.Position = V.Temp.TempVector3
        if V.CSyncVisualization.gui then
            V.CSyncVisualization.gui.img3.ImageColor3 = Config.Aimbot.CSyncVisualizeColor
        end
    end
end

-----------------------
-- HIT SOUND SYSTEM
-----------------------

local AvailableHitSounds = {
    "1nn.mp3","AmongUs.mp3","Bameware.mp3","BatHit.mp3","Beep.mp3","Bonk.mp3","Bow.mp3","Bubble.mp3","Bubble2.mp3","CSGO.mp3","Cod.mp3","Fairy1.mp3","Fairy2.mp3","Fatality.mp3","Fatality2.mp3","Hentai1.mp3","Hentai2.mp3","Hentai3.mp3","Lazer.mp3","MarioCoins.mp3","MinecraftXP.mp3","Neverlose.mp3","OSU.mp3","PubgPan.mp3","Rifk7.mp3","RustHeadshot.mp3","Skeet.mp3","SpanishMoan.mp3","StaryKrow.mp3","Steve.mp3","TF2Crit.mp3","TF2Default.mp3","Windows.mp3","boolean.ogg","disable.ogg","enable.ogg","keypress.ogg","keyrelease.ogg","lobby.mp3","moan1.ogg","moan2.ogg","moan3.ogg","moan4.ogg","orthodox.ogg","pmsound.ogg","rifk.ogg","scroll.ogg","skeet.ogg","swipein.ogg","swipeout.ogg","uwu.ogg"
}

-- Preload all hit sounds once on script start
local function EnsureHitSounds()
    local folder = "SuckBotSounds"
    if not isfolder(folder) then
        makefolder(folder)
    end
    for _, snd in ipairs(AvailableHitSounds) do
        local p = folder .. "/" .. snd
        if not isfile(p) then
            local url = "https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. snd
            pcall(function()
                writefile(p, game:HttpGet(url))
            end)
        end
    end
end

-- Run preload asynchronously so загрузка не блокирует основной поток
pcall(function()
    task.spawn(EnsureHitSounds)
end)

local function GetAsset(path)
    if getsynasset then
        return getsynasset(path)
    elseif getcustomasset then
        return getcustomasset(path)
    else
        return "rbxasset://" .. path
    end
end

local function PlayHitSound()
    if not Config.HitSound.Enabled then return end

    local folder = "SuckBotSounds"
    if not isfolder(folder) then
        makefolder(folder)
    end

    local selectedSound = Config.HitSound.Sound or "CSGO.mp3"
    local filePath = folder .. "/" .. selectedSound

    if not isfile(filePath) then
        local url = "https://github.com/f1nobe7650/Nebula/raw/refs/heads/main/Sounds/" .. selectedSound
        writefile(filePath, game:HttpGet(url))
    end

    local soundService = game:GetService("SoundService")
    local sound = Instance.new("Sound")
    local ok,asset = pcall(function()
        return GetAsset(filePath)
    end)
    if ok and asset then
        sound.SoundId = asset
    else
        warn("[HitSound] Failed to get asset for "..filePath)
        return
    end
    sound.Volume = Config.HitSound.Volume or 1
    sound.PlaybackSpeed = Config.HitSound.Pitch or 1
    sound.Parent = soundService
    pcall(function()
        soundService:PlayLocalSound(sound)
    end)
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

-----------------------
-- DAMAGE DETECTION SYSTEM
-----------------------

local function UpdateDamageDetection()
    if not V.Target or not V.Target.player then
        return
    end
    
    -- Проверяем актуальность ссылок на персонажа и humanoid
    if V.Target.player.Character and V.Target.player.Character ~= V.Target.character then
        -- Персонаж изменился (респавн), обновляем ссылки
        local newCharacter = V.Target.player.Character
        local newHumanoid = newCharacter:FindFirstChildOfClass("Humanoid")
        local newHumanoidRootPart = newCharacter:FindFirstChild("HumanoidRootPart")
        
        if newHumanoid and newHumanoidRootPart then
            V.Target.character = newCharacter
            V.Target.humanoid = newHumanoid
            V.Target.humanoidRootPart = newHumanoidRootPart
            -- Сбрасываем сохраненное здоровье для нового персонажа
            V.LastTargetHealth = nil
            V.LastTargetMaxHealth = nil
            print('[DamageDetection] Обновлены ссылки после респавна цели:', V.Target.name)
        end
    end
    
    -- Проверяем наличие humanoid
    if not V.Target.humanoid or not V.Target.humanoid.Parent then
        return
    end
    
    local currentHealth = V.Target.humanoid.Health
    local currentMaxHealth = V.Target.humanoid.MaxHealth
    
    -- Первичная инициализация
    if V.LastTargetHealth == nil then
        V.LastTargetHealth = currentHealth
        V.LastTargetMaxHealth = currentMaxHealth
        return
    end
    
    -- Проверяем изменение здоровья
    if currentHealth ~= V.LastTargetHealth then
        local damage = V.LastTargetHealth - currentHealth
        local healthPercentage = math.floor((currentHealth / currentMaxHealth) * 100)
        
        if damage > 0 then
            -- Цель получила урон
            local damageInfo = "[DamageDetection] Цель " .. V.Target.name .. " получила урон:"
            
            if Config.DamageDetection.ShowDamage then
                damageInfo = damageInfo .. " -" .. math.floor(damage) .. " HP"
            end
            
            if Config.DamageDetection.ShowHealth then
                damageInfo = damageInfo .. " | Осталось: " .. math.floor(currentHealth) .. "/" .. math.floor(currentMaxHealth) .. " HP"
            end
            
            if Config.DamageDetection.ShowPercentage then
                damageInfo = damageInfo .. " (" .. healthPercentage .. "%)"
            end
            
            print(damageInfo)
            PlayHitSound()
            
            -- Вызываем эффекты попадания: HitChams и/или Skeleton (будет обработано позже)
            if V.Target.player and (Config.HitChams.Enabled or Config.HitChams.Skeleton) then
                -- Сохраняем информацию о том, что нужно показать
                V.ShouldShowHitChams = {
                    player = V.Target.player,
                    showSkeleton = Config.HitChams.Skeleton
                }
            end
            
        elseif damage < 0 then
            -- Цель восстановила здоровье
            V.Temp.TempNumber = math.abs(damage)
            V.Temp.TempString = "[DamageDetection] Цель " .. V.Target.name .. " восстановила здоровье:"
            
            if Config.DamageDetection.ShowDamage then
                V.Temp.TempString = V.Temp.TempString .. " +" .. math.floor(V.Temp.TempNumber) .. " HP"
            end
            
            if Config.DamageDetection.ShowHealth then
                V.Temp.TempString = V.Temp.TempString .. " | Текущее: " .. math.floor(currentHealth) .. "/" .. math.floor(currentMaxHealth) .. " HP"
            end
            
            if Config.DamageDetection.ShowPercentage then
                V.Temp.TempString = V.Temp.TempString .. " (" .. healthPercentage .. "%)"
            end
            
            print(V.Temp.TempString)
        end
        
        -- Обновляем сохраненные значения
        V.LastTargetHealth = currentHealth
        V.LastTargetMaxHealth = currentMaxHealth
    end
end

local function StartDamageDetection()
    if V.DamageDetectionConnection then
        V.DamageDetectionConnection:Disconnect()
        V.DamageDetectionConnection = nil
    end
    
    V.DamageDetectionConnection = V.RS.Heartbeat:Connect(function()
        UpdateDamageDetection()
    end)
    
    print('[DamageDetection] Система детекции урона запущена')
end

local function StopDamageDetection()
    if V.DamageDetectionConnection then
        V.DamageDetectionConnection:Disconnect()
        V.DamageDetectionConnection = nil
        print('[DamageDetection] Система детекции урона остановлена')
    end
    
    -- Сбрасываем сохраненные значения
    V.LastTargetHealth = nil
    V.LastTargetMaxHealth = nil
end

-----------------------
-- HITCHAMS SYSTEM
-----------------------

local function InitHitChamsFolder()
    if not V.HitChamsFolder then
        V.HitChamsFolder = Instance.new("Folder")
        V.HitChamsFolder.Name = "HitChamsFolder"
        V.HitChamsFolder.Parent = V.WS
    end
end

local function HitChams(player)
    if not Config.HitChams.Enabled or not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    InitHitChamsFolder()
    
    player.Character.Archivable = true
    local cloned = player.Character:Clone()
    cloned.Name = "Player Clone"
    
    local bodyParts = {
        "Head", "UpperTorso", "LowerTorso",
        "LeftUpperArm", "LeftLowerArm", "LeftHand",
        "RightUpperArm", "RightLowerArm", "RightHand",
        "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
        "RightUpperLeg", "RightLowerLeg", "RightFoot"
    }
    
    -- Удаляем ненужные части
    for _, part in ipairs(cloned:GetChildren()) do
        if part:IsA("BasePart") then
            local partValid = false
            for _, validPart in ipairs(bodyParts) do
                if part.Name == validPart then
                    partValid = true
                    break
                end
            end
            
            if not partValid then
                part:Destroy()
            end
        elseif part:IsA("Accessory") or part:IsA("Tool") or part.Name == "face" or part:IsA("Shirt") or part:IsA("Pants") or part:IsA("Hat") then
            part:Destroy()
        end
    end
    
    -- Удаляем Humanoid
    if cloned:FindFirstChild("Humanoid") then
        cloned.Humanoid:Destroy()
    end
    
    -- Настраиваем части тела
    for _, bodyPart in ipairs(cloned:GetChildren()) do
        if bodyPart:IsA("BasePart") then
            bodyPart.CanCollide = false
            bodyPart.Anchored = true
            bodyPart.Transparency = Config.HitChams.Transparency
            bodyPart.Color = Config.HitChams.Color
            bodyPart.Material = Enum.Material[Config.HitChams.Material]
        end
    end
    
    cloned.Parent = V.HitChamsFolder
    
    -- Анимация исчезновения
    V.Temp.TweenInfo = TweenInfo.new(
        Config.HitChams.Duration,
        Enum.EasingStyle.Sine,
        Enum.EasingDirection.InOut,
        0,
        false
    )
    
    for _, bodyPart in ipairs(cloned:GetChildren()) do
        if bodyPart:IsA("BasePart") then
            V.Temp.Tween = V.TweenService:Create(bodyPart, V.Temp.TweenInfo, {Transparency = 1})
            V.Temp.Tween:Play()
        end
    end
    
    -- Удаляем клон после анимации
    task.delay(Config.HitChams.Duration, function()
        if cloned and cloned.Parent then
            cloned:Destroy()
        end
    end)
end

local function HitChamsSkeleton(player)
    if not Config.HitChams.Skeleton or not player or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then
        return
    end
    
    local bones = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "RightUpperArm"},
        {"RightUpperArm", "RightLowerArm"},
        {"RightLowerArm", "RightHand"},
        {"UpperTorso", "LeftUpperArm"},
        {"LeftUpperArm", "LeftLowerArm"},
        {"LeftLowerArm", "LeftHand"},
        {"LowerTorso", "RightUpperLeg"},
        {"RightUpperLeg", "RightLowerLeg"},
        {"RightLowerLeg", "RightFoot"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LeftUpperLeg", "LeftLowerLeg"},
        {"LeftLowerLeg", "LeftFoot"}
    }
    
    V.Temp.Lines = {}
    
    for _, bonePair in ipairs(bones) do
        V.Temp.ParentBone = player.Character:FindFirstChild(bonePair[1])
        V.Temp.ChildBone = player.Character:FindFirstChild(bonePair[2])
        
        if V.Temp.ParentBone and V.Temp.ChildBone then
            V.Temp.Line = Instance.new("Part")
            V.Temp.Thickness = Config.HitChams.SkeletonThickness
            V.Temp.Line.Size = V.V3(V.Temp.Thickness, V.Temp.Thickness, (V.Temp.ParentBone.Position - V.Temp.ChildBone.Position).Magnitude)
            V.Temp.Line.CFrame = V.CF(V.Temp.ParentBone.Position, V.Temp.ChildBone.Position) * V.CF(0, 0, -V.Temp.Line.Size.Z / 2)
            V.Temp.Line.Anchored = true
            V.Temp.Line.CanCollide = false
            V.Temp.Line.Material = Enum.Material[Config.HitChams.Material]
            V.Temp.Line.Color = Config.HitChams.SkeletonColor
            V.Temp.Line.Transparency = Config.HitChams.SkeletonTransparency
            V.Temp.Line.CastShadow = false
            V.Temp.Line.Parent = V.WS
            
            V.Temp.TweenInfo = TweenInfo.new(Config.HitChams.SkeletonDuration, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
            V.Temp.Tween = V.TweenService:Create(V.Temp.Line, V.Temp.TweenInfo, {Transparency = 1})
            V.Temp.Tween:Play()
            
            table.insert(V.Temp.Lines, V.Temp.Line)
        end
    end
    
    -- Удаляем линии после анимации
    task.delay(Config.HitChams.SkeletonDuration, function()
        for _, line in ipairs(V.Temp.Lines) do
            if line and line.Parent then
                line:Destroy()
            end
        end
    end)
end

local function ProcessHitChams()
    if V.ShouldShowHitChams then
        local info = V.ShouldShowHitChams
        V.ShouldShowHitChams = nil -- Сбрасываем флаг
        
        if info.player and info.player.Character then
            -- Показываем HitChams только если включен соответствующий тоггл
            if Config.HitChams.Enabled then
                HitChams(info.player)
            end
            -- Скелет отрисовывается независимо от HitChams
            if info.showSkeleton then
                HitChamsSkeleton(info.player)
            end
        end
    end
end

-----------------------
-- TARGET SYSTEM
-----------------------

local function UpdateTarget(target)
    if not target then
        V.Target = nil
        print('[Target] Цель сброшена')
        -- Останавливаем CSync при сбросе цели
        if Config.Aimbot.CSyncEnabled then
            StopCSync()
        end
        -- Останавливаем DamageDetection при сбросе цели
        StopDamageDetection()
        return
    end
    
    if not target:IsA("Player") or not target.Character then
        V.Target = { player = target, name = target.Name }
        return
    end
    
    if not target.Character:FindFirstChild("HumanoidRootPart") or not target.Character:FindFirstChildOfClass("Humanoid") then
        V.Target = { player = target, character = target.Character, name = target.Name }
        return
    end
    
    V.CharCache.TempRoot = target.Character:FindFirstChild("HumanoidRootPart")
    V.CharCache.TempHum = target.Character:FindFirstChildOfClass("Humanoid")
    V.CharCache.RootPart = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
    
    -- Отключаем старые обработчики событий цели
    if V.TargetCharacterRemovingConnection then
        V.TargetCharacterRemovingConnection:Disconnect()
        V.TargetCharacterRemovingConnection = nil
    end
    
    if V.TargetCharacterAddedConnection then
        V.TargetCharacterAddedConnection:Disconnect()
        V.TargetCharacterAddedConnection = nil
    end
    
    -- Обновляем цель
    V.Target = { 
        player = target,
        character = target.Character,
        humanoid = V.CharCache.TempHum,
        humanoidRootPart = V.CharCache.TempRoot,
        name = target.Name,
        distance = V.CharCache.RootPart and (V.CharCache.TempRoot.Position - V.CharCache.RootPart.Position).Magnitude or math.huge,
        position = V.CharCache.TempRoot.Position,
        cframe = V.CharCache.TempRoot.CFrame,
        velocity = V.CharCache.TempRoot.Velocity,
        lastUpdate = tick()
    }
    
    -- Добавляем новые обработчики CharacterRemoving и CharacterAdded для цели
    V.TargetCharacterRemovingConnection = target.CharacterRemoving:Connect(function()
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
    end)
    
    V.TargetCharacterAddedConnection = target.CharacterAdded:Connect(function(character)
        -- Обновляем ссылки на новый персонаж
        task.wait(0.1) -- Небольшая задержка для полной загрузки персонажа
        if V.Target and V.Target.player == target then
            local newHumanoid = character:FindFirstChildOfClass("Humanoid")
            local newHumanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            
            if newHumanoid and newHumanoidRootPart then
                V.Target.character = character
                V.Target.humanoid = newHumanoid
                V.Target.humanoidRootPart = newHumanoidRootPart
                -- Сбрасываем сохраненное здоровье для нового персонажа
                V.LastTargetHealth = nil
                V.LastTargetMaxHealth = nil
                print('[Target] Обновлены ссылки после респавна цели:', V.Target.name)
            end
        end
        
        if V.CurrentHighlight then
            V.CurrentHighlight.Adornee = character
        end
    end)
    
    print('[Target] Выбрана новая цель:', V.Target.name)
    
    -- Автоматически запускаем CSync если он включен
    if Config.Aimbot.CSyncEnabled then
        print('[Target] Автозапуск CSync для новой цели')
        StartCSync()
    end
    if Config.Aimbot.MagicBullets then
        print('[Target] Автозапуск MagicBullets для новой цели')
        StartMagicBullets()
    end
    
    -- Автоматически запускаем DamageDetection (всегда активна)
    print('[Target] Автозапуск DamageDetection для новой цели')
    StartDamageDetection()
end

-----------------------
-- SPEEDHACK FUNCTIONS
-----------------------



-----------------------
-- FLYHACK FUNCTIONS
-----------------------

local function setNoClip(character, state)
    if not character then return end
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if state then
                if not part:GetAttribute("OriginalCollision") then
                    part:SetAttribute("OriginalCollision", part.CanCollide)
                    part:SetAttribute("OriginalTouch", part.CanTouch)
                    part:SetAttribute("OriginalQuery", part.CanQuery)
                end
                part.CanCollide, part.CanTouch, part.CanQuery = false, false, false
            else
                if part:GetAttribute("OriginalCollision") ~= nil then
                    part.CanCollide = part:GetAttribute("OriginalCollision")
                    part.CanTouch = part:GetAttribute("OriginalTouch")
                    part.CanQuery = part:GetAttribute("OriginalQuery")
                    part:SetAttribute("OriginalCollision", nil)
                    part:SetAttribute("OriginalTouch", nil)
                    part:SetAttribute("OriginalQuery", nil)
                end
            end
        end
    end
end

local function UpdateFlyHack(character)
    if V.FlyHackConnection then V.FlyHackConnection:Disconnect(); V.FlyHackConnection = nil end
    if not character then return end
    if not (Config.FlyHack.Enabled and Config.FlyHack.Active) then return end

    setNoClip(character, true)
    V.FlyHackConnection = V.RS.Stepped:Connect(function()
        local char = V.LP.Character
        if not char then return end
        setNoClip(char, true)

        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")
        if not hrp or not hum then return end

        local speed = Config.FlyHack.Speed * 50
        local velocity = V.V3()

        if V.UIS:IsKeyDown(Enum.KeyCode.Space) then velocity = velocity + V.V3(0, speed, 0) end
        if V.UIS:IsKeyDown(Enum.KeyCode.LeftControl) then velocity = velocity + V.V3(0, -speed, 0) end
        if V.UIS:IsKeyDown(Enum.KeyCode.W) then velocity = velocity + (V.Cam.CFrame.LookVector * speed) end
        if V.UIS:IsKeyDown(Enum.KeyCode.S) then velocity = velocity + (V.Cam.CFrame.LookVector * -speed) end
        if V.UIS:IsKeyDown(Enum.KeyCode.D) then velocity = velocity + (V.Cam.CFrame.RightVector * speed) end
        if V.UIS:IsKeyDown(Enum.KeyCode.A) then velocity = velocity + (V.Cam.CFrame.RightVector * -speed) end

        hrp.Velocity = velocity
        hum:ChangeState("Freefall")
    end)
end

local function StopFlyHack()
    if V.FlyHackConnection then V.FlyHackConnection:Disconnect(); V.FlyHackConnection = nil end
    local char = V.LP.Character
    setNoClip(char, false)

    if char then
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local hum = char:FindFirstChild("Humanoid")
        if hrp then
            hrp.Velocity = V.V3(0, -2, 0)
            local tmp
            tmp = V.RS.Stepped:Connect(function()
                if not hrp or not hrp.Parent then tmp:Disconnect() return end
                hrp.Velocity = V.V3(0, hrp.Velocity.Y, 0)
                tmp:Disconnect()
            end)
        end
        if hum then hum:ChangeState("Landing") end
    end
end

local function EnableFlyHack()
    Config.FlyHack.Enabled = true
    if Config.FlyHack.Active then UpdateFlyHack(V.LP.Character) end
end

local function DisableFlyHack()
    Config.FlyHack.Enabled = false
    Config.FlyHack.Active = false
    StopFlyHack()
end

local function SetFlyHackSpeed(val)
    local num = tonumber(val)
    if num then
        num = V.math.clamp(num, 0.1, 100)
        Config.FlyHack.Speed = num
    end
end

-----------------------
-- GRAVITY FUNCTIONS
-----------------------
-----------------------
-- STRAFE FUNCTIONS
-----------------------


local function OnInputBegan(input, gameProcessed)
    if gameProcessed then return end
    

    
    -- FlyHack toggle
    if input.KeyCode == Config.FlyHack.Key then
        if not Config.FlyHack.Enabled then return end
        Config.FlyHack.Active = not Config.FlyHack.Active
        if Config.FlyHack.Active then
            UpdateFlyHack(V.LP.Character)
            print('[FlyHack] Активирован')
        else
            StopFlyHack()
            print('[FlyHack] Деактивирован')
        end
        return
    end
    
    -- Aimbot targeting
    if not Config.Aimbot.Enabled or input.KeyCode ~= Config.Aimbot.StickyKey then return end
    
    if V.Target then
        -- Сбрасываем цель и останавливаем CSync
        print('[Target] Цель сброшена')
        if Config.Aimbot.CSyncEnabled then
            StopCSync()
        end
        V.Target = nil
    else
        local closest = GetClosestPlayerToCursor()
        if closest then
            UpdateTarget(closest) -- Выбираем цель через UpdateTarget
        else
            print('[Target] Не найдено подходящих целей')
        end
    end
end

-----------------------
-- ANTI STOMP FUNCTIONS
-----------------------

local function EnableAntiStomp()
    Config.AntiStomp.Enabled = true
    if V.AntiStompConnection then
        V.AntiStompConnection:Disconnect()
    end

    V.AntiStompConnection = V.RS.Stepped:Connect(function()
        local char = V.LP.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")

        if hum and hum.Health <= Config.AntiStomp.EnableOnHealth then
            local method = Config.AntiStomp.Method

            if method == "Nil_Char" then
                local cam = V.WS.CurrentCamera
                local toDestroy = {}
                for _, v in ipairs(char:GetChildren()) do
                    if v:IsA("MeshPart") or v:IsA("Part") then
                        table.insert(toDestroy, v)
                    elseif v:IsA("Accessory") and v:FindFirstChild("Handle") then
                        table.insert(toDestroy, v.Handle)
                    end
                end
                for _, part in ipairs(toDestroy) do
                    if part and part.Parent then pcall(function() part:Destroy() end) end
                end
                task.spawn(function()
                    task.wait(0.1)
                    if char and char:FindFirstChildOfClass("Humanoid") then
                        cam.CameraSubject = char:FindFirstChildOfClass("Humanoid")
                    end
                end)

            elseif method == "No_Collisions" then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then part.CanCollide = false end
                end

            elseif method == "Remove_Health" then
                hum.Health = 0

            elseif method == "Change_State" then
                hum:ChangeState(Enum.HumanoidStateType.Dead)

            elseif method == "Velocity_Flinger" then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local fling = V.V3(2^16, 2^16, 2^16)
                    hrp.Velocity, hrp.AssemblyLinearVelocity = fling, fling
                end

            elseif method == "Cframe_Flinger" then
                for _, v in ipairs(char:GetChildren()) do
                    if v:IsA("MeshPart") or v:IsA("Part") then
                        v.CFrame = v.CFrame * V.CF(0, 5, 0)
                    end
                end
            end
        end
    end)
end

local function DisableAntiStomp()
    Config.AntiStomp.Enabled = false
    if V.AntiStompConnection then
        V.AntiStompConnection:Disconnect()
        V.AntiStompConnection = nil
    end
end

local function SetAntiStompMethod(method)
    Config.AntiStomp.Method = method
end

local function SetAntiStompHealth(health)
    local num = tonumber(health)
    if num then
        Config.AntiStomp.EnableOnHealth = V.math.clamp(num, 1, 100)
    end
end

-----------------------
-- HIDE (DESYNC) FUNCTIONS
-----------------------

local function GetRandomVoidPosition()
    local angle = V.math.random() * V.math.pi * 2
    local radius = V.math.random() * V.RandomRadius
    local x = V.math.cos(angle) * radius
    local z = V.math.sin(angle) * radius
    return V.CF(x, -1e5, z)
end

function StartHide()
    if V.HideConnection then V.HideConnection:Disconnect() end
    
    V.VoidPosition = V.CF(0, -1e5, 0)
    
    V.HideConnection = V.RS.Heartbeat:Connect(function()
        if V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = V.LP.Character.HumanoidRootPart
            
            if Config.Hide.Enabled then
                V.OriginalCFrame = hrp.CFrame
                
                if Config.Hide.Mode == "Original" then
                    local offset = hrp.CFrame * V.CF(9e9, 0/0, V.math.huge)
                    hrp.CFrame = offset
                elseif Config.Hide.Mode == "Random Void" then
                    V.VoidPosition = GetRandomVoidPosition()
                    hrp.CFrame = V.VoidPosition
                elseif Config.Hide.Mode == "Static Void" then
                    hrp.CFrame = V.VoidPosition
                end
                
                V.RS.RenderStepped:Wait()
                hrp.CFrame = V.OriginalCFrame
            end
        end
    end)
end

function StopHide()
    if V.HideConnection then
        V.HideConnection:Disconnect()
        V.HideConnection = nil
    end
    
    if V.OriginalCFrame and V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart") then
        V.LP.Character.HumanoidRootPart.CFrame = V.OriginalCFrame
    end
end

function EnableHide()
    Config.Hide.Enabled = true
    StartHide()
end

function DisableHide()
    Config.Hide.Enabled = false
    StopHide()
end

local function SetHideMode(mode)
    Config.Hide.Mode = mode
    if Config.Hide.Mode == "Static Void" then
        V.VoidPosition = V.CF(0, -1e5, 0)
    end
end

-- Hide Keybind handled by Linoria KeyPicker attached to Toggle (see UI section)

-----------------------
-- AIMBOT UI
-----------------------

V.AimbotBox = V.Tabs.Aimbot:AddLeftGroupbox('Aimbot Settings')

V.AimbotBox:AddInput('Prediction', {
    Default = '0.1',
    Numeric = true,
    Finished = true,
    Text = 'Prediction',
    Tooltip = 'Значение предикта для аимбота',
    Callback = function(v)
        Config.Aimbot.Prediction = tonumber(v) or 0.1
    end
})

V.AimbotBox:AddDropdown('ResolverMode', {
    Values = {'None', 'Velocity', 'MoveDirection', 'CalculateCFrame'},
    Default = 1,
    Multi = false,
    Text = 'Resolver Mode',
    Tooltip = 'Режим резолвера для предикта',
    Callback = function(v)
        Config.Aimbot.ResolverMode = v
    end
})

V.AimbotBox:AddDropdown('SelectedPart', {
    Values = {'Head', 'HumanoidRootPart', 'UpperTorso', 'LowerTorso'},
    Default = 2,
    Multi = false,
    Text = 'Target Part',
    Tooltip = 'Часть тела для прицеливания',
    Callback = function(v)
        Config.Aimbot.SelectedPart = v
    end
})

V.TargetBox = V.Tabs.Aimbot:AddLeftGroupbox('Targeting')

V.TargetBox:AddToggle('TargetingEnabled', {
    Text = 'Targeting Enabled',
    Default = true,
    Tooltip = 'Включить/выключить систему захвата цели',
    Callback = function(Value)
        Config.Aimbot.Enabled = Value
        print('[Aimbot] Targeting ' .. (Value and 'включен' or 'выключен'))
    end
})

V.TargetBox:AddToggle('AimbotEnabled', {
    Text = 'Aimbot Enabled',
    Default = false,
    Tooltip = 'Включить/выключить аимбот',
    Callback = function(v)
        Config.Aimbot.AimbotEnabled = v
    end
})

V.TargetBox:AddToggle('CSyncEnabled', {
    Text = 'CSync',
    Default = false,
    Tooltip = 'Включить/выключить C-Sync (стрейф вокруг цели)',
    Callback = function(v)
        Config.Aimbot.CSyncEnabled = v
        if v then
            StartCSync()
        else
            StopCSync()
        end
    end
})

V.TargetBox:AddToggle('MagicBullets', {
    Text = 'MagicBullets',
    Default = false,
    Tooltip = 'Пули мгновенно попадают в выбранную цель',
    Callback = function(v)
        Config.Aimbot.MagicBullets = v
    end
})



-- [REMOVED] Предыдущая временная секция 'Hide / Desync'
-- AutoStomp Toggle
V.TargetBox:AddToggle('AutoStompEnabled', {
    Text = 'AutoStomp',
    Default = false,
    Tooltip = 'Автостомп выбитой цели',
    Callback = function(v)
        Config.Aimbot.AutoStompEnabled = v
    end
})

-- GunExploit Toggle
V.TargetBox:AddToggle('GunExploitEnabled', {
    Text = 'GunExploit',
    Default = false,
    Tooltip = 'Автоматически экипирует револьвер, включает рапид фаер и автоперезарядку',
    Callback = function(v)
        Config.Aimbot.GunExploitEnabled = v
        if v then
            StartGunExploit()
        else
            StopGunExploit()
        end
    end
})

-- AutoStomp Settings UI
local AutoStompBox = V.Tabs.Aimbot:AddRightGroupbox('AutoStomp Settings')

AutoStompBox:AddSlider('DelayBeforeStomp', {
    Text = 'Delay Start',
    Default = 0.25,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.Aimbot.DelayBeforeStomp = v
    end
})

AutoStompBox:AddSlider('StompInterval', {
    Text = 'Stomp Interval',
    Default = 0.4,
    Min = 0.1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.Aimbot.StompInterval = v
    end
})







-- Возврат слайдера Y Offset
AutoStompBox:AddSlider('YOffset', {
    Text = 'Y Offset',
    Default = 2,
    Min = -5,
    Max = 5,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.Aimbot.YOffset = v
    end
})

-- Targeting Modes UI
local TargetModeBox = V.Tabs.Aimbot:AddLeftGroupbox('Targeting modes')
TargetModeBox:AddDropdown('TargetMode', {
    Values = {'Sticky','Nuker'},
    Default = 1,
    Multi = false,
    Text = 'Target Mode',
    Tooltip = 'Выбор режима захвата цели',
    Callback = function(v)
        Config.Aimbot.TargetMode = v
    end
})

V.TargetBox:AddLabel('Sticky Key'):AddKeyPicker('StickyKeybind', {
    Default = 'Q',
    SyncToggleState = false,
    Text = 'Sticky Target',
    NoUI = false,
    Tooltip = 'Клавиша для захвата/сброса цели',
    ChangedCallback = function(New)
        -- Сбрасываем текущую цель при смене кейбинда
        if V.Target then
            print('[Target] Цель сброшена при смене кейбинда')
            if Config.Aimbot.CSyncEnabled then
                StopCSync()
            end
            V.Target = nil
        end
        
        Config.Aimbot.StickyKey = (function()
            -- Если New уже EnumItem, используем его напрямую
            if typeof(New) == "EnumItem" then
                print('[Aimbot] Sticky keybind изменен на:', New.Name)
                return New
            end
            -- Если New строка, конвертируем в EnumItem
            local kc = Enum.KeyCode[New] or Enum.KeyCode.Unknown
            if kc ~= Enum.KeyCode.Unknown then
                print('[Aimbot] Sticky keybind изменен на:', New)
                return kc
            else
                warn('[Aimbot] Некорректный keybind:', New)
                return Enum.KeyCode.Unknown
            end
        end)()
    end
})

-----------------------
-- SKIP SETTINGS UI
-----------------------

V.SkipBox = V.Tabs.Aimbot:AddRightGroupbox('Skip')
V.SkipBox:AddToggle('SkipCovered', {
    Text = 'Skip Covered',
    Default = false,
    Tooltip = 'Пропускать игроков, которые находятся за стеной',
    Callback = function(v)
        Config.Aimbot.SkipCovered = v
    end
})

V.SkipBox:AddToggle('SkipKnocked', {
    Text = 'Skip Knocked',
    Default = false,
    Tooltip = 'Пропускать игроков, которые в нокауте',
    Callback = function(v)
        Config.Aimbot.SkipKnocked = v
    end
})

V.SkipBox:AddToggle('SkipGrabbed', {
    Text = 'Skip Grabbed',
    Default = false,
    Tooltip = 'Пропускать игроков, которых держат',
    Callback = function(v)
        Config.Aimbot.SkipGrabbed = v
    end
})

-----------------------
-- RESET TARGET ON UI
-----------------------

V.ResetBox = V.Tabs.Aimbot:AddRightGroupbox('ResetTargetON')
V.ResetBox:AddToggle('ResetKnocked', {
    Text = 'Knocked',
    Default = false,
    Tooltip = 'Сбрасывать цель, если она нокаутирована',
    Callback = function(v)
        Config.Aimbot.ResetKnocked = v
    end
})
V.ResetBox:AddToggle('ResetGrabbed', {
    Text = 'Grabbed',
    Default = false,
    Tooltip = 'Сбрасывать цель, если её схватили',
    Callback = function(v)
        Config.Aimbot.ResetGrabbed = v
    end
})
V.ResetBox:AddToggle('ResetDeath', {
    Text = 'Death',
    Default = false,
    Tooltip = 'Сбрасывать цель при смерти',
    Callback = function(v)
        Config.Aimbot.ResetDeath = v
    end
})

-----------------------
-- VISUALIZATIONS UI
-----------------------

V.VisBox = V.Tabs.Aimbot:AddRightGroupbox('Visualizations')

V.HLToggle = V.VisBox:AddToggle('TargetHighlight', {
    Text = 'Target Highlight',
    Default = false,
    Tooltip = 'Подсвечивать выбранную цель',
    Callback = function(v)
        Config.TargetHighlight.Enabled = v
        if not v and V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
    end
})

V.HLToggle:AddColorPicker('OutlineColor', {
    Default = Color3.new(1, 0, 0),
    Title = 'Outline Color',
    Callback = function(color)
        Config.TargetHighlight.OutlineColor = color
    end
})

V.VisBox:AddSlider('OutlineTransparency', {
    Text = 'Outline Transparency',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.TargetHighlight.OutlineTransparency = v
    end
})

V.VisBox:AddSlider('FillTransparency', {
    Text = 'Fill Transparency',
    Default = 0.5,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.TargetHighlight.FillTransparency = v
    end
})

-----------------------
-- HITCHAMS UI
-----------------------

V.HitChamsBox = V.Tabs.Aimbot:AddRightGroupbox('HitChams')

V.HitChamsToggle = V.HitChamsBox:AddToggle('HitChamsEnabled', {
    Text = 'HitChams',
    Default = false,
    Tooltip = 'Показывать эффект при получении урона целью',
    Callback = function(v)
        Config.HitChams.Enabled = v
        if v then
            InitHitChamsFolder()
        end
    end
})

V.HitChamsToggle:AddColorPicker('HitChamsColor', {
    Default = Color3.new(1, 0, 0),
    Title = 'HitChams Color',
    Transparency = false,
    Callback = function(c)
        Config.HitChams.Color = c
    end
})

V.HitChamsBox:AddSlider('HitChamsDuration', {
    Text = 'Duration',
    Default = 2,
    Min = 0.5,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.HitChams.Duration = v
    end
})

V.HitChamsBox:AddDropdown('HitChamsMaterial', {
    Values = {'Neon', 'Glass', 'ForceField', 'Plastic'},
    Default = 'Neon',
    Multi = false,
    Text = 'Material',
    Callback = function(v)
        Config.HitChams.Material = v
    end
})

V.HitChamsBox:AddSlider('HitChamsTransparency', {
    Text = 'Transparency',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.HitChams.Transparency = v
    end
})

V.HitChamsBox:AddToggle('HitChamsSkeleton', {
    Text = 'Skeleton',
    Default = false,
    Tooltip = 'Показывать скелет при получении урона',
    Callback = function(v)
        Config.HitChams.Skeleton = v
    end
}):AddColorPicker('SkeletonColor', {
    Default = Color3.new(155/255, 0, 155/255),
    Title = 'Skeleton Color',
    Transparency = false,
    Callback = function(c)
        Config.HitChams.SkeletonColor = c
    end
})

V.HitChamsBox:AddSlider('SkeletonDuration', {
    Text = 'Skeleton Duration',
    Default = 1.5,
    Min = 0.5,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.HitChams.SkeletonDuration = v
    end
})

V.HitChamsBox:AddSlider('SkeletonTransparency', {
    Text = 'Skeleton Transparency',
    Default = 0,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.HitChams.SkeletonTransparency = v
    end
})

V.HitChamsBox:AddSlider('SkeletonThickness', {
    Text = 'Skeleton Thickness',
    Default = 0.1,
    Min = 0.1,
    Max = 1,
    Rounding = 3,
    Compact = false,
    Callback = function(v)
        Config.HitChams.SkeletonThickness = v
    end
})

-----------------------
-- BULLET TRACERS UI
-----------------------

local BulletTracersBox = V.Tabs.Visuals:AddLeftGroupbox('BulletTracers')

local BulletTracersToggle = BulletTracersBox:AddToggle('BulletTracers', {
    Text = 'BulletTracers',
    Default = false,
    Tooltip = 'Показывать трассеры пуль',
    Callback = function(v)
        Config.BulletTracers.Enabled = v
        if v then
            InitBulletTracers()
        else
            CleanupBulletTracers()
        end
    end
})

BulletTracersToggle:AddColorPicker('BulletTracerColor', {
    Default = Color3.new(1, 1, 1),
    Title = 'Tracer Color',
    Callback = function(color)
        Config.BulletTracers.Color = color
    end
})

BulletTracersBox:AddDropdown('TracerMode', {
    Values = {'Drawing', 'Texture'},
    Default = 1,
    Multi = false,
    Text = 'Mode',
    Tooltip = 'Режим отображения трассеров: Drawing (2D линии) или Texture (3D beam)',
    Callback = function(v)
        Config.BulletTracers.Mode = v
        -- Очищаем активные трассеры при смене режима
        if Config.BulletTracers.Enabled then
            CleanupBulletTracers()
            InitBulletTracers()
        end
    end
})

BulletTracersBox:AddSlider('TracerThickness', {
    Text = 'Thickness',
    Default = 2,
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Толщина трассеров (для Drawing и Texture режимов)',
    Callback = function(v)
        Config.BulletTracers.Thickness = v
    end
})

BulletTracersBox:AddSlider('TracerDuration', {
    Text = 'Duration',
    Default = 0.6,
    Min = 0.1,
    Max = 3.0,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Время жизни трассеров в секундах',
    Callback = function(v)
        Config.BulletTracers.Duration = v
    end
})

-----------------------
-- CSYNC SETTINGS UI
-----------------------

local CSyncBox = V.Tabs.Aimbot:AddRightGroupbox('CSync Settings')

CSyncBox:AddSlider('CSyncRange', {
    Text = 'Strafe Range',
    Default = 10,
    Min = 5,
    Max = 50,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Радиус стрейфа вокруг цели',
    Callback = function(v)
        Config.Aimbot.CSyncRange = v or 10
    end
})

CSyncBox:AddSlider('CSyncHeight', {
    Text = 'Height Variation',
    Default = 5,
    Min = 0,
    Max = 30,
    Rounding = 1,
    Compact = false,
    Tooltip = 'Вариация высоты стрейфа',
    Callback = function(v)
        Config.Aimbot.CSyncHeight = v or 5
    end
})

local CSyncVisToggle = CSyncBox:AddToggle('CSyncVisualize', {
    Text = 'Visualize',
    Default = false,
    Tooltip = 'Визуализация позиции десинка',
    Callback = function(v)
        Config.Aimbot.CSyncVisualize = v
        UpdateCSyncVisualization()
    -- Обновление камеры произойдёт автоматически через RenderStepped
    end
})

CSyncVisToggle:AddColorPicker('CSyncVisualizeColor', {
    Default = Color3.new(1, 1, 1),
    Title = 'Visualize Color',
    Callback = function(color)
        Config.Aimbot.CSyncVisualizeColor = color
        if V.CSyncVisualization and V.CSyncVisualization.gui then
            V.CSyncVisualization.gui.img3.ImageColor3 = color
        end
    end
})

local function AutoResetTarget()
    if not V.Target or not V.Target.player then return end
    
    if (Config.Aimbot.ResetKnocked and IsPlayerKO(V.Target.player)) or
       (Config.Aimbot.ResetGrabbed and IsPlayerGrabbed(V.Target.player)) or
       (Config.Aimbot.ResetDeath and (not V.Target.player.Character or not V.Target.player.Character:FindFirstChildOfClass('Humanoid') or V.Target.player.Character:FindFirstChildOfClass('Humanoid').Health <= 0)) then
        print('[ResetTarget] Сброс цели')
        V.Target = nil
    end
end


-----------------------
-- MAGIC BULLETS FUNCTION
-----------------------
function ShootAtPlayer(player)
    if not player or not player.Character or not Config.Aimbot.MagicBullets then return end
    -- Проверка патронов
    V.Temp.WeaponTool = V.LP.Character and V.LP.Character:FindFirstChildWhichIsA("Tool")
    if V.Temp.WeaponTool then
        V.Temp.Ammo = V.Temp.WeaponTool:FindFirstChild("Ammo")
        if V.Temp.Ammo and V.Temp.Ammo.Value <= 0 then return end
    end
    -- Не стреляем по мёртвым, но разрешаем стрелять по Grabbed
    if IsPlayerKO(player) then return end
    -- Ждём пока ForceField исчезнет, чтобы bullets прошли
    if player.Character:FindFirstChildOfClass("ForceField") then return end
    V.Temp.Head = player.Character:FindFirstChild("Head")
    if not V.Temp.Head then return end
    V.CharCache.TempChar = V.LP.Character
    if not V.CharCache.TempChar then return end
    V.Temp.Weapon = nil
    for _, tool in ipairs(V.CharCache.TempChar:GetChildren()) do
        if tool:IsA("Tool") then
            V.Temp.Weapon = tool
            break
        end
    end
    if not V.Temp.Weapon then return end
    V.Temp.Handle = V.Temp.Weapon:FindFirstChild("Handle")
    if not V.Temp.Handle then return end
    V.Temp.HeadPos = V.Temp.Head.Position
    V.Temp.Args = {
        "ShootGun",
        V.Temp.Handle,
        V.Temp.HeadPos,
        {V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos},
        {V.Temp.Head, V.Temp.Head, V.Temp.Head, V.Temp.Head, V.Temp.Head},
        {Vector3.new(0,1,0),Vector3.new(0,1,0),Vector3.new(0,1,0),Vector3.new(0,1,0),Vector3.new(0,1,0)},
        {},
        os.clock(),
        99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999,
        {V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos, V.Temp.HeadPos},
        5,
        0.2,
        V.Temp.HeadPos
    }
    V.Temp.ShootEvent = V.RSStorage:FindFirstChild("ShootEvent")
    if V.Temp.ShootEvent then
        V.Temp.ShootEvent:FireServer(unpack(V.Temp.Args))
    end
end

-----------------------
-- MISC UI (ANTI STOMP)
-----------------------

V.AntiStompBox = V.Tabs.Misc:AddLeftGroupbox('Anti Stomp')

V.AntiStompBox:AddToggle('AntiStompEnabled', {
    Text = 'Anti Stomp Enabled',
    Default = false,
    Tooltip = 'Включить/выключить защиту от стомпа',
    Callback = function(v)
        Config.AntiStomp.Enabled = v
        if v then
            EnableAntiStomp()
        else
            DisableAntiStomp()
        end
    end
})

V.AntiStompBox:AddDropdown('AntiStompMethod', {
    Values = {'Nil_Char', 'No_Collisions', 'Remove_Health', 'Change_State', 'Velocity_Flinger', 'Cframe_Flinger'},
    Default = 1,
    Multi = false,
    Text = 'Method',
    Tooltip = 'Метод защиты от стомпа',
    Callback = function(v)
        SetAntiStompMethod(v)
    end
})

V.AntiStompBox:AddSlider('AntiStompHealth', {
    Text = 'Health Threshold',
    Default = 99,
    Min = 1,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Tooltip = 'Порог здоровья для активации Anti Stomp',
    Callback = function(v)
        SetAntiStompHealth(v)
    end
})

-- SpeedHack секция
V.SpeedHackBox = V.Tabs.Misc:AddRightGroupbox('SpeedHack')

V.SpeedHackBox:AddInput('SpeedHackSpeed', {
    Default = '50',
    Numeric = true,
    Finished = true,
    Text = 'Speed',
    Tooltip = 'Скорость спидхака (1-500)',
    Callback = function(v)
        getgenv().SetSpeedhackSpeed(v)
    end
})

V.SpeedHackBox:AddToggle('SpeedHackEnabled', {
    Text = 'SpeedHack Enabled',
    Default = false,
    Tooltip = 'Включить/выключить спидхак (общее разрешение)',
    Callback = function(v)
        if v then
            getgenv().EnableSpeedhack()
        else
            getgenv().DisableSpeedhack()
        end
    end
})

V.SpeedHackBox:AddLabel('SpeedHack Key'):AddKeyPicker('SpeedHackKeybind', {
    Default = 'X',
    SyncToggleState = false,
    Text = 'SpeedHack Activity',
    NoUI = false,
    Tooltip = 'Клавиша для активации спидхака (только при включенном Enabled)',
    ChangedCallback = function(New)
        -- Сбрасываем активность SpeedHack при смене кейбинда
        if getgenv().SpeedhackConfig and getgenv().SpeedhackConfig.Active then
            getgenv().SpeedhackConfig.Active = false
            print('[SpeedHack] Активность сброшена при смене кейбинда')
        end
        
        getgenv().SpeedhackConfig.Keybind = (function()
            -- Если New уже EnumItem, используем его напрямую
            if typeof(New) == "EnumItem" then
                print('[SpeedHack] Keybind изменен на:', New.Name)
                return New
            end
            -- Если New строка, конвертируем в EnumItem
            local kc = Enum.KeyCode[New] or Enum.KeyCode.Unknown
            if kc ~= Enum.KeyCode.Unknown then
                print('[SpeedHack] Keybind изменен на:', New)
                return kc
            else
                warn('[SpeedHack] Некорректный keybind:', New)
                return Enum.KeyCode.Unknown
            end
        end)()
    end
})

-- FlyHack секция
V.FlyHackBox = V.Tabs.Misc:AddLeftGroupbox('FlyHack')

V.FlyHackBox:AddInput('FlyHackSpeed', {
    Default = '1',
    Numeric = true,
    Finished = true,
    Text = 'Speed',
    Tooltip = 'Скорость полёта (0.1-100)',
    Callback = function(v)
        SetFlyHackSpeed(v)
    end
})

V.FlyHackBox:AddToggle('FlyHackEnabled', {

    Text = 'FlyHack Enabled',
    Default = false,
    Tooltip = 'Включить/выключить флайхак',
    Callback = function(v)
        Config.FlyHack.Enabled = v
        if v then
            EnableFlyHack()
        else
            DisableFlyHack()
        end
    end
})

-- RAPIDFIRE SECTION -----------------------
V.RapidFireBox = V.Tabs.Misc:AddLeftGroupbox('RapidFire')

V.RapidFireBox:AddToggle('RapidFireEnabled', {
    Text = 'RapidFire',
    Default = false,
    Tooltip = 'Включить RapidFire',
    Callback = function(v)
        Config.RapidFire.Enabled = v
    end
})


-- GUN RANGE EXPLOIT SECTION -----------------------
V.GunRangeBox = V.Tabs.Misc:AddLeftGroupbox('GunRangeExploit')

V.GunRangeBox:AddToggle('GunRangeEnabled', {
    Text = 'Gun Range Exploit',
    Default = false,
    Tooltip = 'Включить изменение дальности оружия',
    Callback = function(v)
        Config.GunRangeExploit.Enabled = v
    end
})

V.GunRangeBox:AddInput('GunRangeValue', {
    Default = tostring(Config.GunRangeExploit.Range),
    Numeric = true,
    Finished = true,
    Text = 'Range Value',
    Tooltip = 'Новое значение Range',
    Callback = function(v)
        local num = tonumber(v)
        if num and num > 0 then
            Config.GunRangeExploit.Range = num
        end
    end
})

V.FlyHackBox:AddLabel('FlyHack Key'):AddKeyPicker('FlyHackKeybind', {
    Default = 'F',
    SyncToggleState = false,
    Text = 'FlyHack Toggle',
    NoUI = false,
    Tooltip = 'Клавиша для включения/выключения полёта (только при включенном FlyHack)',
    ChangedCallback = function(New)
        -- Сбрасываем состояние FlyHack при смене кейбинда
        if Config.FlyHack.Active then
            Config.FlyHack.Active = false
            StopFlyHack()
            print('[FlyHack] Отключен при смене кейбинда')
        end
        
        Config.FlyHack.Key = (function()
            -- Если New уже EnumItem, используем его напрямую
            if typeof(New) == "EnumItem" then
                print('[FlyHack] Keybind изменен на:', New.Name)
                return New
            end
            -- Если New строка, конвертируем в EnumItem
            local kc = Enum.KeyCode[New] or Enum.KeyCode.Unknown
            if kc ~= Enum.KeyCode.Unknown then
                print('[FlyHack] Keybind изменен на:', New)
                return kc
            else
                warn('[FlyHack] Некорректный keybind:', New)
                return Enum.KeyCode.Unknown
            end
        end)()
    end
})

-- Hide секция
V.HideBox = V.Tabs.Misc:AddRightGroupbox('Hide')

V.UI.HideToggle = V.HideBox:AddToggle('HideEnabled', {
    Text = 'Hide Enabled',
    Default = false,
    Tooltip = 'Включить/выключить систему скрытия (desync)',
    Callback = function(v)
        Config.Hide.Enabled = v
        if v then
            EnableHide()
        else
            DisableHide()
        end
    end
})

-- Кейбинд для Hide: привязываем к существующему тогглу через KeyPicker
do
    local function keyName()
        local k = (Config.Hide and Config.Hide.Key) or Enum.KeyCode.H
        return typeof(k) == 'EnumItem' and k.Name or tostring(k)
    end
    if V.UI and V.UI.HideToggle and V.UI.HideToggle.AddKeyPicker then
        V.UI.HideToggle:AddKeyPicker('HideKeybind', {
            Default = keyName(),
            SyncToggleState = true,
            Mode = 'Toggle',
            Text = 'Hide Key',
            NoUI = false,
            Tooltip = 'Клавиша для переключения Hide',
            ChangedCallback = function(New)
                local kc = nil
                if typeof(New) == 'EnumItem' then
                    kc = New
                elseif type(New) == 'string' and Enum.KeyCode[New] then
                    kc = Enum.KeyCode[New]
                end
                if kc then
                    Config.Hide.Key = kc
                    print('[Hide] Keybind set to', kc.Name)
                else
                    warn('[Hide] Invalid keybind:', tostring(New))
                end
            end
        })
    end
end

V.HideBox:AddDropdown('HideMode', {
    Values = {'Original', 'Random Void', 'Static Void'},
    Default = 1,
    Multi = false,
    Text = 'Mode',
    Tooltip = 'Режим скрытия персонажа',
    Callback = function(v)
        SetHideMode(v)
    end
})

-- Strafe секция
V.StrafeBox = V.Tabs.Misc:AddRightGroupbox('Strafe')

V.StrafeBox:AddToggle('StrafeEnabled', {
    Text = 'Strafe Enabled',
    Default = Config.Strafe.Enabled,
    Tooltip = 'Включить/выключить Strafe (буст движения в воздухе)',
    Callback = function(v)
        Config.Strafe.Enabled = v
        if V.Strafe and V.Strafe.Toggle then V.Strafe.Toggle(v) end
    end
})

V.StrafeBox:AddSlider('StrafeStrength', {
    Text = 'Strafe Strength',
    Default = Config.Strafe.Strength,
    Min = 0.1,
    Max = 10,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        if V.Strafe and V.Strafe.SetStrength then V.Strafe.SetStrength(v) else Config.Strafe.Strength = v end
    end
})

-----------------------
-- CONNECTIONS
-----------------------
V.RS.RenderStepped:Connect(function()
    AutoResetTarget()
    if Config.Aimbot.TargetMode == 'Nuker' and GetClosestPlayerToCursor() and (not V.Target or V.Target.player ~= GetClosestPlayerToCursor()) then
        UpdateTarget(GetClosestPlayerToCursor())
    end
    UpdateTargetHighlight(); UpdateCSyncVisualization();  if Config.Aimbot.AutoStompEnabled and ApplyAutoStomp then ApplyAutoStomp() end; UpdateBulletTracers()
    
    if Config.BulletTracers.Enabled then
        for _, child in pairs(V.WS.Ignored:GetChildren()) do
            if child.Name == "BULLET_RAYS" then child:Destroy() end
        end
    end
    if Config.Aimbot.MagicBullets and V.Target and V.Target.player and os.clock() - (V.LastMagicShoot or 0) > 0.06 then
        ShootAtPlayer(V.Target.player); V.LastMagicShoot = os.clock()
    end
end)
V.UIS.InputBegan:Connect(OnInputBegan)

-- SpeedHack respawn support
V.LP.CharacterAdded:Connect(function(char)
    if not Config["SpeedHack"] then Config["SpeedHack"] = {Enabled=false} end
    if not Config.FlyHack then Config.FlyHack = {Enabled=false,Active=false} end
    if not Config.Chams then Config.Chams = {Enabled=false,Color=Color3.new(1,1,1),FillTransparency=0.5} end

    if Config["SpeedHack"] and Config["SpeedHack"].Enabled and _G and type(_G.UpdateSpeedHack) == 'function' then
        _G.UpdateSpeedHack(char)
    end
    -- FlyHack respawn support
    if Config.FlyHack and Config.FlyHack.Enabled and Config.FlyHack.Active then
        UpdateFlyHack(char)
    end
end)

V.Save:BuildConfigSection(V.Tabs.Config)
V.ThemeBox = V.Tabs.Config:AddLeftGroupbox('')
V.Theme:ApplyToGroupbox(V.ThemeBox)
V.Theme:LoadDefault()
V.Save:LoadAutoloadConfig()

-----------------------
-- C-SYNC SPOOF HOOK
local __csync
__csync = hookmetamethod(game, "__index", function(t,k)
    if not checkcaller() and k=="CFrame" and V.SavedDesync and Config.Aimbot.CSyncEnabled then
        local lpRoot = V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart")
        if t==lpRoot then
            return V.SavedDesync
        end
    end
    return __csync(t,k)
end)

-------------------------------------------------
-- RAPIDFIRE & M1 SPAM LOGIC
-------------------------------------------------
local Orginal = {}
local Traced = { RapidFire = true }


-- Heartbeat connection holder
local RapidConn

local function StartRapidFire()
    if RapidConn then return end
    Traced.RapidFire = true
    RapidConn = V.RS.RenderStepped:Connect(function()
        V.WeaponCache.Tool = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Tool")
        if V.WeaponCache.Tool and V.WeaponCache.Tool:FindFirstChild("GunScript") then
            for _, connection in ipairs(getconnections(V.WeaponCache.Tool.Activated)) do
                V.FuncCache.Func = connection.Function
                if V.FuncCache.Func then
                    V.FuncCache.Info = debug.getinfo(V.FuncCache.Func)
                    for i = 1, V.FuncCache.Info.nups do
                        V.FuncCache.Val = debug.getupvalue(V.FuncCache.Func, i)
                        if type(V.FuncCache.Val) == "number" then
                            if not Orginal[i] then Orginal[i] = V.FuncCache.Val end
                            debug.setupvalue(V.FuncCache.Func, i, 1e-9)
                        end
                    end
                end
            end
        end
    end)
end

local function StopRapidFire()
    Traced.RapidFire = false
    if RapidConn then RapidConn:Disconnect(); RapidConn=nil end
    -- restore originals once
    V.WeaponCache.Tool = V.LP.Character and V.LP.Character:FindFirstChildOfClass("Tool")
    if V.WeaponCache.Tool and V.WeaponCache.Tool:FindFirstChild("GunScript") then
        for _, connection in ipairs(getconnections(V.WeaponCache.Tool.Activated)) do
            V.FuncCache.Func = connection.Function
            if V.FuncCache.Func then
                V.FuncCache.Info = debug.getinfo(V.FuncCache.Func)
                for i = 1, V.FuncCache.Info.nups do
                    if Orginal[i] then
                        debug.setupvalue(V.FuncCache.Func, i, Orginal[i])
                    end
                end
            end
        end
    end
end

-------------------------------------------------
-- GUN RANGE EXPLOIT LOGIC
-------------------------------------------------
local function ApplyRangeToTool(tool)
    if tool then
        local r = tool:FindFirstChild("Range")
        if r and r:IsA("ValueBase") then
            r.Value = Config.GunRangeExploit.Range
        end
    end
end

local function UpdateGunRanges()
    if not Config.GunRangeExploit.Enabled then return end
    -- tools in character, backpack и модели в workspace.Players
    local wPlayerModel = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild(V.LP.Name)
    for _, parent in ipairs({V.LP.Character, V.LP.Backpack, wPlayerModel}) do
        if parent then
            for _, tool in ipairs(parent:GetChildren()) do
                ApplyRangeToTool(tool)
            end
        end
    end
end

-- heartbeat connection
local RangeConn = V.RS.Heartbeat:Connect(UpdateGunRanges)

-- also when tool added
local function ToolAdded(tool)
    if Config.GunRangeExploit.Enabled then ApplyRangeToTool(tool) end
end
if V.LP.Character then V.LP.Character.ChildAdded:Connect(ToolAdded) end
V.LP.Backpack.ChildAdded:Connect(ToolAdded)

-- RAPIDFIRE LOGIC
-- Watch for toggle changes
local lastRapid = false
V.RS.RenderStepped:Connect(function()
    if Config.RapidFire.Enabled ~= lastRapid then
        lastRapid = Config.RapidFire.Enabled
        if lastRapid then StartRapidFire() else StopRapidFire() end
    end




end)

-- AIMBOT HOOK
-----------------------
local __aimbot
__aimbot = hookmetamethod(game, "__index", function(t, k)
    if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
        if not Check() then
            return __aimbot(t, k)
        end

        local selPart = V.Target.character and V.Target.character:FindFirstChild(Config.Aimbot.SelectedPart)
        if selPart then
            local predictedPos = GetPredictedPosition(V.Target.player) or selPart.Position
            local hit = V.CF(predictedPos)
            return k == "Hit" and hit or selPart
        end
    end
    return __aimbot(t, k)
end)

-- HIDE HOOK
-----------------------
V.HideHook = hookmetamethod(game, "__index", function(t, k)
    if not checkcaller() and k == "CFrame" and Config.Hide.Enabled and V.LP.Character and V.LP.Character:FindFirstChild("HumanoidRootPart") and V.LP.Character:FindFirstChild("Humanoid") and V.LP.Character:FindFirstChild("Humanoid").Health > 0 then
        if t == V.LP.Character.HumanoidRootPart and V.OriginalCFrame ~= nil then
            return V.OriginalCFrame
        end
    end
    return V.HideHook(t, k)
end)

--================== SPEEDHACK ==================--

-- Конфиг
if not getgenv().SpeedhackConfig then
    getgenv().SpeedhackConfig = {
        Enabled  = false,
        Active   = false,
        Speed    = 50,
        Keybind  = Enum.KeyCode.X
    }
end

-- Обновление спидхака
local speedHackConnection
local function updateSpeedHack(character)
    if not character then return end
    V.CharCache.TempRoot = character:WaitForChild("HumanoidRootPart")
    V.CharCache.TempHum = character:WaitForChild("Humanoid")

    if speedHackConnection then speedHackConnection:Disconnect() end
    speedHackConnection = V.RS.Heartbeat:Connect(function(dt)
        if getgenv().SpeedhackConfig.Enabled and getgenv().SpeedhackConfig.Active then
            V.Temp.TempVector3 = V.CharCache.TempHum.MoveDirection
            if V.Temp.TempVector3.Magnitude > 0 then
                V.CharCache.TempRoot.CFrame = V.CharCache.TempRoot.CFrame + (V.Temp.TempVector3.Unit * getgenv().SpeedhackConfig.Speed * dt)
            end
        end
    end)
end

-- Публичные функции
getgenv().EnableSpeedhack = function()
    getgenv().SpeedhackConfig.Enabled = true
    updateSpeedHack(V.LP.Character)
end

getgenv().DisableSpeedhack = function()
    getgenv().SpeedhackConfig.Enabled = false
    getgenv().SpeedhackConfig.Active  = false
    if speedHackConnection then speedHackConnection:Disconnect(); speedHackConnection = nil end
end

getgenv().ToggleSpeedhackKey = function()
    if not getgenv().SpeedhackConfig.Enabled then return end
    getgenv().SpeedhackConfig.Active = not getgenv().SpeedhackConfig.Active
end

getgenv().SetSpeedhackSpeed = function(val)
    local num = tonumber(val)
    if num then
        num = V.math.clamp(num,1,2000000)
        getgenv().SpeedhackConfig.Speed = num
    end
end

-- Поддержка респавна
V.LP.CharacterAdded:Connect(function(char)
    if getgenv().SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
end)

-- SPEEDHACK INPUT HANDLING
-----------------------
V.UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- SpeedHack Keybind
    if input.KeyCode == getgenv().SpeedhackConfig.Keybind then
        getgenv().ToggleSpeedhackKey()
    end
end)
--------------------------------------------------

-- CHAMS SYSTEM

local R15Parts = {
    Head = true, UpperTorso = true, LowerTorso = true,
    LeftUpperArm = true, LeftLowerArm = true, LeftHand = true,
    RightUpperArm = true, RightLowerArm = true, RightHand = true,
    LeftUpperLeg = true, LeftLowerLeg = true, LeftFoot = true,
    RightUpperLeg = true, RightLowerLeg = true, RightFoot = true
}

local function CreateFillBox(part)
    local box = Instance.new("BoxHandleAdornment")
    box.Name = "ChamsFill"
    box.Adornee = part
    box.Size = part.Size
    box.Color3 = Config.Chams.Color
    box.Transparency = Config.Chams.Transparency
    box.AlwaysOnTop = true
    box.ZIndex = 1
    box.Parent = part
    return box
end

local function AddChams(player)
    if player == V.LP then return end -- skip local player
    if not player.Character then return end
    local character = player.Character
    if V.ChamsObjects[character] then return end
    local list = {}
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and R15Parts[part.Name] then
            local box = CreateFillBox(part)
            if box then table.insert(list, box) end
        end
    end
    if #list > 0 then
        V.ChamsObjects[character] = list
    end
    -- listen for new parts appearing in character (e.g. after respawn)
    local conn
    conn = character.ChildAdded:Connect(function(part)
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and R15Parts[part.Name] then
            if V.ChamsObjects[character]==nil then V.ChamsObjects[character]={} end
            local box = CreateFillBox(part)
            table.insert(V.ChamsObjects[character], box)
        end
    end)
    table.insert(V.ChamsConnections, conn)
end

local function RemoveChams(character)
    if V.ChamsObjects[character] then
        for _, box in ipairs(V.ChamsObjects[character]) do
            if box and box.Parent then box:Destroy() end
        end
        V.ChamsObjects[character] = nil
    end
end

--============ MATERIAL CHAMS (FORCEFIELD) ============--
local function ApplyMaterialChams(character)
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" and R15Parts[part.Name] then
            if part.Material ~= Enum.Material.ForceField then
                part.Material = Enum.Material.ForceField
                part.Color = Config.MaterialChams.Color
                part.Transparency = Config.MaterialChams.Transparency
            end
        end
    end
end

local function _EnableMaterialChams()
    -- очистка старых соединений
    for _,c in ipairs(V.MaterialChamsConnections) do c:Disconnect() end
    V.MaterialChamsConnections = {}

    -- запускаем периодический цикл 1.5 cек
    if not V.MaterialChamsLoop then
        V.MaterialChamsLoop = task.spawn(function()
            while Config.MaterialChams.Enabled do
                for _,plr in ipairs(V.Players:GetPlayers()) do
                    if plr ~= V.LP and plr.Character then
                        ApplyMaterialChams(plr.Character)
                    end
                end
                task.wait(1.5)
            end
            V.MaterialChamsLoop = nil
        end)
    end

    -- применяем к существующим игрокам
    for _,plr in ipairs(V.Players:GetPlayers()) do
        if plr ~= V.LP and plr.Character then
            ApplyMaterialChams(plr.Character)
            -- childadded
            table.insert(V.MaterialChamsConnections, plr.Character.ChildAdded:Connect(function(obj)
                if obj:IsA("BasePart") and R15Parts[obj.Name] then
                    if Config.MaterialChams.Enabled then
                        obj.Material = Enum.Material.ForceField
                        obj.Color = Config.MaterialChams.Color
                        obj.Transparency = Config.MaterialChams.Transparency
                    end
                end
            end))
        end
    end

    -- новые игроки
    table.insert(V.MaterialChamsConnections, V.Players.PlayerAdded:Connect(function(p)
        if p ~= V.LP then
            table.insert(V.MaterialChamsConnections, p.CharacterAdded:Connect(function(char)
                task.wait(1)
                if Config.MaterialChams.Enabled then
                    ApplyMaterialChams(char)
                    table.insert(V.MaterialChamsConnections, char.ChildAdded:Connect(function(obj)
                        if obj:IsA("BasePart") and R15Parts[obj.Name] then
                            if Config.MaterialChams.Enabled then
                                obj.Material = Enum.Material.ForceField
                                obj.Color = Config.MaterialChams.Color
                                obj.Transparency = Config.MaterialChams.Transparency
                            end
                        end
                    end))
                end
            end))
        end
    end))
end

local function _DisableMaterialChams()
    for _,c in ipairs(V.MaterialChamsConnections) do c:Disconnect() end
    V.MaterialChamsConnections = {}
    -- восстановим материал у всех не-локальных игроков (упрощённо)
    for _,plr in ipairs(V.Players:GetPlayers()) do
        if plr~=V.LP and plr.Character then
            for _,part in ipairs(plr.Character:GetChildren()) do
                if part:IsA("BasePart") and R15Parts[part.Name] then
                    if part.Material == Enum.Material.ForceField then
                        part.Material = Enum.Material.Plastic
                        part.Transparency = 0
                    end
                end
            end
        end
    end
end

local function _UpdateMaterialChamsColor()
    if not Config.MaterialChams.Enabled then return end
    for _,plr in ipairs(V.Players:GetPlayers()) do
        if plr~=V.LP and plr.Character then
            for _,part in ipairs(plr.Character:GetChildren()) do
                if part:IsA("BasePart") and R15Parts[part.Name] then
                    if part.Material == Enum.Material.ForceField then
                        part.Color = Config.MaterialChams.Color
                        part.Transparency = Config.MaterialChams.Transparency
                    end
                end
            end
        end
    end
end

local function CleanupChams()
    for character,_ in pairs(V.ChamsObjects) do
        RemoveChams(character)
    end
    for _,conn in ipairs(V.ChamsConnections) do conn:Disconnect() end
    V.ChamsConnections = {}
end

local function UpdateChamsVisual()
    for _, boxes in pairs(V.ChamsObjects) do
        for _, box in ipairs(boxes) do
            if box then
                box.Color3 = Config.Chams.Color
                box.Transparency = Config.Chams.Transparency
            end
        end
    end
end

local function EnableChams()
    -- CRITICAL FIX: Clear existing connections first to prevent stacking
    CleanupChams()
    
    -- apply to existing players
    for _,plr in ipairs(V.Players:GetPlayers()) do AddChams(plr) end
    
    -- setup connections (only once)
    table.insert(V.ChamsConnections, V.Players.PlayerAdded:Connect(function(p)
        if p ~= V.LP then
            table.insert(V.ChamsConnections, p.CharacterAdded:Connect(function()
                task.wait(1)
                AddChams(p)
            end))
        end
    end))
    
    table.insert(V.ChamsConnections, V.Players.PlayerRemoving:Connect(function(p)
        if p.Character then RemoveChams(p.Character) end
    end))
    
    -- character respawn for current players
    for _,p in ipairs(V.Players:GetPlayers()) do
        if p ~= V.LP then
            table.insert(V.ChamsConnections, p.CharacterAdded:Connect(function()
                task.wait(1)
                AddChams(p)
            end))
            table.insert(V.ChamsConnections, p.CharacterRemoving:Connect(function(char)
                RemoveChams(char)
            end))
        end
    end
end

local function DisableChams()
    CleanupChams()
end

-- UI Elements
local ChamsBox = V.Tabs.Visuals:AddRightGroupbox('Chams')
local ChamsToggle = ChamsBox:AddToggle('ChamsEnabled', {
    Text = 'Enabled',
    Default = Config.Chams.Enabled,
    Callback = function(v)
        Config.Chams.Enabled = v
        if v then EnableChams() else DisableChams() end
    end
})

ChamsToggle:AddColorPicker('ChamsColor', {
    Default = Config.Chams.Color,
    Title = 'Color',
    Transparency = false,
    Callback = function(c)
        Config.Chams.Color = c
        UpdateChamsVisual()
    end
})

ChamsBox:AddSlider('ChamsTransparency', {
    Text = 'Transparency',
    Default = Config.Chams.Transparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = true,
    Callback = function(v)
        Config.Chams.Transparency = v
        UpdateChamsVisual()
    end
})

if Config.Chams.Enabled then
    EnableChams()
end

-- MATERIAL CHAMS SYSTEM
-- Дублирующие функции удалены (используются определения на строках 3801-3890)

-- SELF MATERIAL SYSTEM

--================ SELF HIGHLIGHT SYSTEM ===============--
local function ApplySelfHighlight(character)
    if V.SelfHighlight then V.SelfHighlight:Destroy() end
    local hl = Instance.new("Highlight")
    hl.Name = "SelfHighlight"
    hl.Adornee = character
    hl.FillColor = Config.SelfHighlights.FillColor
    hl.OutlineColor = Config.SelfHighlights.OutlineColor
    hl.FillTransparency = Config.SelfHighlights.FillTransparency
    hl.OutlineTransparency = Config.SelfHighlights.OutlineTransparency
    hl.Parent = character
    V.SelfHighlight = hl
end

local function EnableSelfHighlight()
    if not Config.SelfHighlights.Enabled then return end
    if not V.LP.Character then return end
    ApplySelfHighlight(V.LP.Character)
    if not V.SelfHighlightConnection then
        V.SelfHighlightConnection = V.LP.CharacterAdded:Connect(function(char)
            task.wait(0.5)
            if Config.SelfHighlights.Enabled then
                ApplySelfHighlight(char)
            end
        end)
    end
end

local function DisableSelfHighlight()
    if V.SelfHighlight then
        V.SelfHighlight:Destroy()
        V.SelfHighlight = nil
    end
    if V.SelfHighlightConnection then
        V.SelfHighlightConnection:Disconnect()
        V.SelfHighlightConnection = nil
    end
end

local function UpdateSelfHighlightVisual()
    if not V.SelfHighlight then return end
    V.SelfHighlight.FillColor = Config.SelfHighlights.FillColor
    V.SelfHighlight.OutlineColor = Config.SelfHighlights.OutlineColor
    V.SelfHighlight.FillTransparency = Config.SelfHighlights.FillTransparency
    V.SelfHighlight.OutlineTransparency = Config.SelfHighlights.OutlineTransparency
end

-- SELF MATERIAL SYSTEM
local function HideClothes(character)
    if not character then return end
    local folder = character:FindFirstChild("SimpleBotHiddenClothes")
    if not folder then
        folder = Instance.new("Folder")
        folder.Name = "SimpleBotHiddenClothes"
        folder.Parent = character
    end
    for _, obj in ipairs(character:GetChildren()) do
        if obj:IsA("Shirt") or obj:IsA("Pants") or obj:IsA("ShirtGraphic") then
            obj.Parent = folder
        end
    end
end

local function RestoreClothes(character)
    if not character then return end
    local folder = character:FindFirstChild("SimpleBotHiddenClothes")
    if folder then
        for _, obj in ipairs(folder:GetChildren()) do
            obj.Parent = character
        end
        folder:Destroy()
    end
end

local function ApplyForceFieldBody(character)
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and R15Parts[part.Name] then
            -- Сохраняем оригинальный цвет перед изменением
            if not V.OriginalBodyColors[part.Name] then
                V.OriginalBodyColors[part.Name] = part.Color
            end
            if part.Material ~= Enum.Material.ForceField then
                part.Material = Enum.Material.ForceField
                part.Color = Config.SelfMaterial.Color
            end
        end
    end
end

local function EnableSelfMaterial()
    if not Config.SelfMaterial.Enabled then return end
    if not V.LP.Character then return end

    -- Очищаем сохраненные цвета при новом включении
    V.OriginalBodyColors = {}
    
    ApplyForceFieldBody(V.LP.Character)
    HideClothes(V.LP.Character)

    -- ChildAdded для новых частей без постоянного цикла
    if not V.SelfMaterialChildConn then
        V.SelfMaterialChildConn = V.LP.Character.ChildAdded:Connect(function(obj)
            if obj:IsA("BasePart") and R15Parts[obj.Name] then
                if Config.SelfMaterial.Enabled then
                    -- Сохраняем оригинальный цвет новой части
                    if not V.OriginalBodyColors[obj.Name] then
                        V.OriginalBodyColors[obj.Name] = obj.Color
                    end
                    obj.Material = Enum.Material.ForceField
                    obj.Color = Config.SelfMaterial.Color
                end
            end
        end)
    end

    -- Обработчик респавна
    if not V.SelfMaterialConnection then
        V.SelfMaterialConnection = V.LP.CharacterAdded:Connect(function(character)
            task.wait(0.5)
            if Config.SelfMaterial.Enabled then
                -- Очищаем сохраненные цвета при респавне
                V.OriginalBodyColors = {}
                ApplyForceFieldBody(character)
                HideClothes(character)
                -- пере-подключаем ChildAdded
                if V.SelfMaterialChildConn then V.SelfMaterialChildConn:Disconnect() end
                V.SelfMaterialChildConn = character.ChildAdded:Connect(function(obj)
                    if obj:IsA("BasePart") and R15Parts[obj.Name] then
                        if Config.SelfMaterial.Enabled then
                            -- Сохраняем оригинальный цвет новой части
                            if not V.OriginalBodyColors[obj.Name] then
                                V.OriginalBodyColors[obj.Name] = obj.Color
                            end
                            obj.Material = Enum.Material.ForceField
                            obj.Color = Config.SelfMaterial.Color
                        end
                    end
                end)
            end
        end)
    end
end

local function DisableSelfMaterial()
    if V.SelfMaterialConnection then V.SelfMaterialConnection:Disconnect() V.SelfMaterialConnection=nil end
    if V.SelfMaterialChildConn then V.SelfMaterialChildConn:Disconnect() V.SelfMaterialChildConn=nil end
    if V.LP.Character then
        RestoreClothes(V.LP.Character)
        for _, part in ipairs(V.LP.Character:GetChildren()) do
            if part:IsA("BasePart") and R15Parts[part.Name] then
                part.Material = Enum.Material.Plastic
                -- Восстанавливаем оригинальный цвет или используем стандартный цвет кожи
                if V.OriginalBodyColors[part.Name] then
                    part.Color = V.OriginalBodyColors[part.Name]
                else
                    -- Стандартные цвета для частей тела Roblox
                    if part.Name:find("Hand") or part.Name:find("Foot") or part.Name == "Head" then
                        part.Color = Color3.fromRGB(255, 204, 153)  -- Цвет кожи
                    else
                        part.Color = Color3.fromRGB(255, 204, 153)  -- Цвет кожи для всех частей
                    end
                end
            end
        end
    end
end

-- SELF ACCESSORY MATERIAL SYSTEM
-- Гарантируем, что конфиг существует до использования
if not Config.SelfAccessoryMaterial then
    Config.SelfAccessoryMaterial = {Enabled=false, Color=Color3.new(1,1,1)}
end
-- Зарезервируем поля подключения в таблице V
V.SelfAccessoryMaterialConnection = V.SelfAccessoryMaterialConnection or nil
V.SelfAccessoryChildConn = V.SelfAccessoryChildConn or nil
V.SelfMaterialChildConn = V.SelfMaterialChildConn or nil
local function ApplyForceFieldAccessory(character)
    for _, accessory in ipairs(character:GetChildren()) do
        if accessory:IsA("Accessory") and accessory:FindFirstChild("Handle") then
            V.Temp.Handle = accessory.Handle
            if V.Temp.Handle.Material ~= Enum.Material.ForceField then
                V.Temp.Handle.Material = Enum.Material.ForceField
                V.Temp.Handle.Color = Config.SelfAccessoryMaterial.Color
            end
        end
    end
end

local function EnableSelfAccessoryMaterial()
    if not Config.SelfAccessoryMaterial or not Config.SelfAccessoryMaterial.Enabled then return end
    if not V.LP.Character then return end

    ApplyForceFieldAccessory(V.LP.Character)

    -- ChildAdded для аксессуаров
    if not V.SelfAccessoryChildConn then
        V.SelfAccessoryChildConn = V.LP.Character.ChildAdded:Connect(function(obj)
            if obj:IsA("Accessory") and obj:FindFirstChild("Handle") then
                if Config.SelfAccessoryMaterial.Enabled then
                    obj.Handle.Material = Enum.Material.ForceField
                    obj.Handle.Color = Config.SelfAccessoryMaterial.Color
                end
            end
        end)
    end

    if not V.SelfAccessoryMaterialConnection then
        V.SelfAccessoryMaterialConnection = V.LP.CharacterAdded:Connect(function(character)
            task.wait(0.5)
            if Config.SelfAccessoryMaterial.Enabled then
                ApplyForceFieldAccessory(character)
                if V.SelfAccessoryChildConn then V.SelfAccessoryChildConn:Disconnect() end
                V.SelfAccessoryChildConn = character.ChildAdded:Connect(function(obj)
                    if obj:IsA("Accessory") and obj:FindFirstChild("Handle") then
                        if Config.SelfAccessoryMaterial.Enabled then
                            obj.Handle.Material = Enum.Material.ForceField
                            obj.Handle.Color = Config.SelfAccessoryMaterial.Color
                        end
                    end
                end)
            end
        end)
    end
end

local function DisableSelfAccessoryMaterial()
    if V.SelfAccessoryMaterialConnection then V.SelfAccessoryMaterialConnection:Disconnect() V.SelfAccessoryMaterialConnection=nil end
    if V.SelfAccessoryChildConn then V.SelfAccessoryChildConn:Disconnect() V.SelfAccessoryChildConn=nil end
    if V.LP.Character then
        for _, accessory in ipairs(V.LP.Character:GetChildren()) do
            if accessory:IsA("Accessory") and accessory:FindFirstChild("Handle") then
                accessory.Handle.Material = Enum.Material.Plastic
                accessory.Handle.Color = Color3.new(1,1,1)
            end
        end
    end
end

local function UpdateSelfAccessoryMaterialColor()
    if not Config.SelfAccessoryMaterial or not Config.SelfAccessoryMaterial.Enabled then return end
    if not V.LP.Character then return end
    for _, accessory in ipairs(V.LP.Character:GetChildren()) do
        if accessory:IsA("Accessory") and accessory:FindFirstChild("Handle") then
            accessory.Handle.Color = Config.SelfAccessoryMaterial.Color
        end
    end
end

local function UpdateSelfMaterialColor()
    if not Config.SelfMaterial.Enabled then return end
    if not V.LP.Character then return end
    
    for _, part in ipairs(V.LP.Character:GetChildren()) do
        if part:IsA("BasePart") and R15Parts[part.Name] then
            part.Color = Config.SelfMaterial.Color
        end
    end
end

-- TRACERS SYSTEM
local function ClearTracers()
    for _,ln in pairs(V.TracerLines) do pcall(function() ln.Visible=false ln:Remove() end) end
    V.TracerLines = {}
    if V.TracerLoopConnection then V.TracerLoopConnection:Disconnect() V.TracerLoopConnection=nil end
end

local function UpdateTracerVisual()
    for _,ln in pairs(V.TracerLines) do
        ln.Color = Config.Tracers.Color
        ln.Transparency = 1-Config.Tracers.Transparency
        ln.Thickness = Config.Tracers.Thickness
    end
end

local function EnableTracers()
    ClearTracers()
    V.TracerLoopConnection = V.RS.RenderStepped:Connect(function()
        -- Используем кешированные переменные
        V.TracerScreenSize = V.Cam.ViewportSize
        
        if Config.Tracers.StartPosition == 'Mouse' then
            V.MouseLocation = V.UIS:GetMouseLocation()
            V.TracerStartVector = V.V2(V.MouseLocation.X, V.MouseLocation.Y)
        elseif Config.Tracers.StartPosition == 'Middle' then
            V.TracerStartVector = V.V2(V.TracerScreenSize.X/2, V.TracerScreenSize.Y/2)
        elseif Config.Tracers.StartPosition == 'Top' then
            V.TracerStartVector = V.V2(V.TracerScreenSize.X/2, 0)
        else -- Bottom
            V.TracerStartVector = V.V2(V.TracerScreenSize.X/2, V.TracerScreenSize.Y)
        end
        -- reuse existing lines if same count
        local idx=1
        for _,plr in ipairs(V.Players:GetPlayers()) do
            if plr~=V.LP and plr.Character and plr.Character:FindFirstChild('HumanoidRootPart') then
                local part = Config.Tracers.EndPart=='Head' and plr.Character:FindFirstChild('Head') or plr.Character:FindFirstChild('HumanoidRootPart')
                if part then
                    V.TracerPos, V.TracerVis = V.Cam:WorldToViewportPoint(part.Position)
                    if not V.TracerVis and Config.Tracers.ShowBehind then
                        V.TracerTemp = V.Cam.CFrame:PointToObjectSpace(part.Position)
                        V.TracerTemp = CFrame.Angles(0,0,(math.atan2(V.TracerTemp.Y,V.TracerTemp.X)+math.pi)):VectorToWorldSpace((CFrame.Angles(0,math.rad(89.9),0):VectorToWorldSpace(V.V3(0,0,-1))))
                        V.TracerPos = V.Cam:WorldToViewportPoint(V.Cam.CFrame:PointToWorldSpace(V.TracerTemp))
                        V.TracerVis=true
                    end
                    if V.TracerVis then
                        local line = V.TracerLines[idx]
                        if not line then
                            line = Drawing.new('Line')
                            V.TracerLines[idx]=line
                        end
                        line.Visible=true
                        line.From=V.TracerStartVector
                        line.To=V.V2(V.TracerPos.X,V.TracerPos.Y)
                        if Config.Tracers.TargetTracerEnabled and V.Target and V.Target.player==plr then
                            line.Color = Config.Tracers.TargetTracerColor
                        else
                            line.Color = Config.Tracers.Color
                        end
                        line.Thickness=Config.Tracers.Thickness
                        line.Transparency=1-Config.Tracers.Transparency
                        idx=idx+1
                    end
                end
            end
        end
        -- hide extra lines
        for i=idx,#V.TracerLines do
            if V.TracerLines[i] then V.TracerLines[i].Visible=false end
        end
    end)
end

local function DisableTracers()
    ClearTracers()
end

-- UI Elements for Tracers
local TracerBox = V.Tabs.Visuals:AddRightGroupbox('Tracers')
local TracerToggle = TracerBox:AddToggle('TracersEnabled',{
    Text='Enabled',
    Default=Config.Tracers.Enabled,
    Callback=function(v)
        Config.Tracers.Enabled=v
        if v then EnableTracers() else DisableTracers() end
    end
})
TracerToggle:AddColorPicker('TracerColor',{
    Default=Config.Tracers.Color,
    Title='Color',
    Transparency=false,
    Callback=function(c)
        Config.Tracers.Color=c
        UpdateTracerVisual()
    end
})
TracerBox:AddSlider('TracerTransparency',{
    Text='Transparency',
    Default=Config.Tracers.Transparency,
    Min=0,Max=1,Rounding=2,Compact=true,
    Callback=function(v)
        Config.Tracers.Transparency=v
        UpdateTracerVisual()
    end
})
TracerBox:AddSlider('TracerThickness',{
    Text='Thickness',
    Default=Config.Tracers.Thickness,
    Min=1,Max=5,Rounding=0,Compact=true,
    Callback=function(v)
        Config.Tracers.Thickness=v
        UpdateTracerVisual()
    end
})
TracerBox:AddDropdown('TracerStart',{
    Values={'Bottom','Middle','Mouse','Top'},
    Default=Config.Tracers.StartPosition,
    Multi=false,
    Text='Start Pos',
    Callback=function(v)
        Config.Tracers.StartPosition=v
    end
})
TracerBox:AddDropdown('TracerEnd',{
    Values={'Torso','Head'},
    Default=Config.Tracers.EndPart,
    Multi=false,
    Text='End Part',
    Callback=function(v)
        Config.Tracers.EndPart=v
    end
})
local TargetTracerToggle = TracerBox:AddToggle('TargetTracerToggle',{
    Text='TargetTracer',
    Default=Config.Tracers.TargetTracerEnabled,
    Callback=function(v)
        Config.Tracers.TargetTracerEnabled=v
    end
})
TargetTracerToggle:AddColorPicker('TargetTracerColor',{
    Default=Config.Tracers.TargetTracerColor,
    Title='Target Color',
    Transparency=false,
    Callback=function(c)
        Config.Tracers.TargetTracerColor=c
    end
})

TracerBox:AddToggle('TracerBehind',{
    Text='Show Behind',
    Default=Config.Tracers.ShowBehind,
    Callback=function(v)
        Config.Tracers.ShowBehind=v
    end
})

if Config.Tracers.Enabled then EnableTracers() end



-- GUARANTEE CONFIG SELF HIGHLIGHTS
if not Config.SelfHighlights then
    Config.SelfHighlights = {
        Enabled = false,
        FillColor = Color3.new(1, 1, 0),
        OutlineColor = Color3.new(1, 0, 0),
        FillTransparency = 0,
        OutlineTransparency = 0
    }
end

-- SELF MATERIAL UI
-- Добавляем дефолтный конфиг для аксессуаров, если его нет
if not Config.SelfAccessoryMaterial then
    Config.SelfAccessoryMaterial = {
        Enabled = false,
        Color = Color3.new(1,1,1)
    }
end
local SelfMaterialBox = V.Tabs.Visuals:AddLeftGroupbox('SelfMaterial')
local SelfMaterialToggle = SelfMaterialBox:AddToggle('SelfMaterialEnabled', {
    Text = 'Enabled',
    Default = Config.SelfMaterial.Enabled,
    Tooltip = 'Заменяет материал локального игрока на ForceField',
    Callback = function(v)
        Config.SelfMaterial.Enabled = v
        if v then EnableSelfMaterial() else DisableSelfMaterial() end
    end
})

SelfMaterialToggle:AddColorPicker('SelfMaterialColor', {
    Default = Config.SelfMaterial.Color,
    Title = 'ForceField Color',
    Transparency = false,
    Callback = function(c)
        Config.SelfMaterial.Color = c
        UpdateSelfMaterialColor()
    end
})

-- Toggle для аксессуаров
local SelfAccessoryToggle = SelfMaterialBox:AddToggle('SelfAccessoryEnabled', {
    Text = 'Accessories Only',
    Default = Config.SelfAccessoryMaterial.Enabled,
    Tooltip = 'Заменяет материал аксессуаров локального игрока на ForceField',
    Callback = function(v)
        Config.SelfAccessoryMaterial.Enabled = v
        if v then EnableSelfAccessoryMaterial() else DisableSelfAccessoryMaterial() end
    end
})

SelfAccessoryToggle:AddColorPicker('SelfAccessoryColor', {
    Default = Config.SelfAccessoryMaterial.Color,
    Title = 'Accessory Color',
    Transparency = false,
    Callback = function(c)
        Config.SelfAccessoryMaterial.Color = c
        UpdateSelfAccessoryMaterialColor()
    end
})

-- SELF HIGHLIGHTS UI
local SelfHighlightBox = V.Tabs.Visuals:AddLeftGroupbox('SelfHighlights')
local SelfHighlightToggle = SelfHighlightBox:AddToggle('SelfHighlightEnabled', {
    Text = 'Enabled',
    Default = Config.SelfHighlights.Enabled,
    Tooltip = 'Подсвечивает вашего персонажа Highlight-ом',
    Callback = function(v)
        Config.SelfHighlights.Enabled = v
        if v then EnableSelfHighlight() else DisableSelfHighlight() end
    end
})

-- Fill Color
SelfHighlightToggle:AddColorPicker('SelfHighlightFillColor', {
    Default = Config.SelfHighlights.FillColor,
    Title = 'Fill Color',
    Transparency = false,
    Callback = function(c)
        Config.SelfHighlights.FillColor = c
        UpdateSelfHighlightVisual()
    end
})

-- Outline Color
SelfHighlightToggle:AddColorPicker('SelfHighlightOutlineColor', {
    Default = Config.SelfHighlights.OutlineColor,
    Title = 'Outline Color',
    Transparency = false,
    Callback = function(c)
        Config.SelfHighlights.OutlineColor = c
        UpdateSelfHighlightVisual()
    end
})

-- Fill Transparency slider
SelfHighlightBox:AddSlider('SelfHighlightFillTrans', {
    Text = 'Fill Transparency',
    Min = 0, Max = 1, Rounding = 2, Compact = true,
    Default = Config.SelfHighlights.FillTransparency,
    Callback = function(v)
        Config.SelfHighlights.FillTransparency = v
        UpdateSelfHighlightVisual()
    end
})

-- Outline Transparency slider
SelfHighlightBox:AddSlider('SelfHighlightOutlineTrans', {
    Text = 'Outline Transparency',
    Min = 0, Max = 1, Rounding = 2, Compact = true,
    Default = Config.SelfHighlights.OutlineTransparency,
    Callback = function(v)
        Config.SelfHighlights.OutlineTransparency = v
        UpdateSelfHighlightVisual()
    end
})

-----------------------
-- JUMP CIRCLES SYSTEM
-----------------------
-- Вспомогательная функция: создать и анимировать один круг
local function _CreateAndAnimateJumpCircle(targetPos, targetSize, color, textureId)
    if not targetPos then return end
    -- Создаем Part
    V.InstCache.TempPart = Instance.new('Part')
    V.InstCache.TempPart.Name = 'SB_JumpCircle'
    V.InstCache.TempPart.Anchored = true
    V.InstCache.TempPart.CanCollide = false
    V.InstCache.TempPart.Material = Enum.Material.SmoothPlastic
    V.InstCache.TempPart.Transparency = 1
    V.InstCache.TempPart.Size = Vector3.new(1, 0.05, 1)
    V.InstCache.TempPart.CFrame = CFrame.new(targetPos)
    V.InstCache.TempPart.Parent = V.WS

    -- SurfaceGui с ImageLabel (круглая текстура)
    V.InstCache.TempBillboard = Instance.new('SurfaceGui')
    V.InstCache.TempBillboard.Name = 'SB_JumpCircleGui'
    V.InstCache.TempBillboard.Face = Enum.NormalId.Top
    V.InstCache.TempBillboard.AlwaysOnTop = true
    V.InstCache.TempBillboard.SizingMode = Enum.SurfaceGuiSizingMode.PixelsPerStud
    V.InstCache.TempBillboard.PixelsPerStud = 64
    V.InstCache.TempBillboard.Parent = V.InstCache.TempPart

    V.InstCache.TempImage = Instance.new('ImageLabel')
    V.InstCache.TempImage.Name = 'Image'
    V.InstCache.TempImage.BackgroundTransparency = 1
    -- нормализуем textureId к формату 'rbxassetid://<digits>'
    V.Temp.TempString = tostring(textureId or "")
    V.Temp.TempString2 = V.Temp.TempString:match('%d+') or ''
    if #V.Temp.TempString2 > 0 then
        V.Temp.TempString = 'rbxassetid://' .. V.Temp.TempString2
    end
    V.InstCache.TempImage.Image = (#V.Temp.TempString > 0 and V.Temp.TempString) or (V.JumpCircles.Texture1 or 'rbxassetid://7216856276')
    V.InstCache.TempImage.ImageColor3 = color or Color3.new(1,1,1)
    V.InstCache.TempImage.ImageTransparency = 0.2
    V.InstCache.TempImage.Size = UDim2.fromScale(1, 1)
    V.InstCache.TempImage.Parent = V.InstCache.TempBillboard

    -- Анимация расширения и исчезновения без TweenService (чтобы не добавлять сервис)
    task.spawn(function(part)
        -- Находим GUI/Image заново, чтобы избежать гонок указателей из InstCache
        local gui = part and part:FindFirstChild('SB_JumpCircleGui')
        local img = gui and gui:FindFirstChild('Image')
        V.Temp.TempNumber = 0
        V.Temp.TempNumber2 = 0.6 -- длительность
        while V.Temp.TempNumber < V.Temp.TempNumber2 do
            V.Temp.TempNumber = V.Temp.TempNumber + V.RS.Heartbeat:Wait()
            -- интерполяция размера 0 -> targetSize
            V.Temp.TempNumber3 = math.clamp(V.Temp.TempNumber / V.Temp.TempNumber2, 0, 1)
            V.Temp.TempNumber4 = targetSize * V.Temp.TempNumber3
            if part then
                part.Size = Vector3.new(math.max(0.1, V.Temp.TempNumber4), 0.05, math.max(0.1, V.Temp.TempNumber4))
            end
            if img then
                -- Фаза 1: растём до размера и доводим прозрачность только до 0.8
                img.ImageTransparency = 0.2 + 0.6 * V.Temp.TempNumber3
            end
        end
        -- Фаза 2: жизнь после достижения максимума
        local hold = (Config.JumpCircles and Config.JumpCircles.LifeAfterMax) or 0
        if hold > 0 then
            local t = 0
            local startTrans = (img and img.ImageTransparency) or 0.8
            while t < hold do
                t = t + V.RS.Heartbeat:Wait()
                if img then
                    local k = math.clamp(t / hold, 0, 1)
                    img.ImageTransparency = startTrans + (1 - startTrans) * k
                end
            end
        end
        if part then part:Destroy() end
    end, V.InstCache.TempPart)
end

local function _OnJump()
    if not Config.JumpCircles.Enabled then return end
    if not V.LP or not V.LP.Character then return end
    V.CharCache.TempRoot = V.LP.Character:FindFirstChild('HumanoidRootPart')
    if not V.CharCache.TempRoot then return end
    -- гарантируем наличие текстур по умолчанию
    V.JumpCircles.Texture1 = V.JumpCircles.Texture1 or 'rbxassetid://7216856276'
    V.JumpCircles.Texture2 = V.JumpCircles.Texture2 or 'rbxassetid://6707322206'
    -- Позиция круга
    V.Temp.TempVector3 = V.CharCache.TempRoot.Position + Vector3.new(0, 0.05, 0)
    -- Размер круга и запуск только одного круга с первой текстурой
    V.Temp.TempNumber = Config.JumpCircles.Size
    _CreateAndAnimateJumpCircle(V.Temp.TempVector3, V.Temp.TempNumber, Config.JumpCircles.Color1, V.JumpCircles.Texture1)
end

local function _AttachCharacter(char)
    if not char then return end
    V.CharCache.TempHum = char:FindFirstChildOfClass('Humanoid')
    if not V.CharCache.TempHum then return end
    -- Подписка на смену состояния -> Jumping
    if V.JumpCircles.Connections["State"] then V.JumpCircles.Connections["State"]:Disconnect() end
    V.JumpCircles.Connections["State"] = V.CharCache.TempHum.StateChanged:Connect(function(_, new)
        if new == Enum.HumanoidStateType.Jumping then
            _OnJump()
        end
    end)
end

function EnableJumpCircles()
    if not Config.JumpCircles.Enabled then return end
    -- Подключаемся к текущему персонажу и хендлим респавны
    if V.JumpCircles.Connections["CharAdded"] then V.JumpCircles.Connections["CharAdded"]:Disconnect() end
    V.JumpCircles.Connections["CharAdded"] = V.LP.CharacterAdded:Connect(function(char)
        task.defer(function()
            _AttachCharacter(char)
        end)
    end)
    if V.LP.Character then _AttachCharacter(V.LP.Character) end
end

function DisableJumpCircles()
    for k, conn in pairs(V.JumpCircles.Connections) do
        if typeof(conn) == 'RBXScriptConnection' then conn:Disconnect() end
        V.JumpCircles.Connections[k] = nil
    end
end

-- UI: Jump circles (левая колонка Visuals)
local JumpCirclesBox = V.Tabs.Visuals:AddLeftGroupbox('Jump circles')
local JumpCirclesToggle = JumpCirclesBox:AddToggle('JumpCirclesEnabled', {
    Text = 'Enabled',
    Default = Config.JumpCircles.Enabled,
    Tooltip = 'Одна окружность при прыжке',
    Callback = function(v)
        Config.JumpCircles.Enabled = v
        if v then EnableJumpCircles() else DisableJumpCircles() end
    end
})

JumpCirclesToggle:AddColorPicker('JumpCirclesColor1', {
    Default = Config.JumpCircles.Color1,
    Title = 'Color',
    Transparency = false,
    Callback = function(c)
        Config.JumpCircles.Color1 = c
    end
})

JumpCirclesBox:AddSlider('JumpCirclesSize', {
    Text = 'Size',
    Min = 6, Max = 40, Rounding = 0, Compact = true,
    Default = Config.JumpCircles.Size,
    Callback = function(v)
        Config.JumpCircles.Size = v
    end
})

-- UI + Logic: Textures (левая колонка Visuals, последняя секция)
-- Вспомогательные функции для Textures
local function _IsCharacterDescendant(inst)
    V.Temp.Part = inst
    while V.Temp.Part and V.Temp.Part.Parent do
        if V.Temp.Part:IsA('Model') then
            V.Temp.TempHum = V.Temp.Part:FindFirstChildOfClass('Humanoid')
            if V.Temp.TempHum then
                -- Проверяем, что это персонаж игрока
                V.Temp.Player = V.Players:GetPlayerFromCharacter(V.Temp.Part)
                return V.Temp.Player ~= nil
            end
        end
        V.Temp.Part = V.Temp.Part.Parent
    end
    return false
end

local function _ApplyMaterialToPart(part)
    if not part or not part:IsA('BasePart') then return end
    if _IsCharacterDescendant(part) then return end
    -- Сохраняем оригинал один раз
    V.Textures.Originals = V.Textures.Originals or {}
    if V.Textures.Originals[part] == nil then
        V.Textures.Originals[part] = part.Material
    end
    -- Применяем выбранный материал
    V.Temp.TempString = Config.Textures.Selected or 'Plastic'
    V.Temp.Value = Enum.Material[V.Temp.TempString] or Enum.Material.Plastic
    part.Material = V.Temp.Value
end

function EnableTextures()
    -- Подготовка списка материалов для дропдауна (один раз)
    if not V.MaterialList then
        V.Temp.TempTable = {}
        for _, m in ipairs(Enum.Material:GetEnumItems()) do
            table.insert(V.Temp.TempTable, m.Name)
        end
        V.MaterialList = V.Temp.TempTable
    end
    -- Первичный проход по Workspace
    for _, d in ipairs(V.WS:GetDescendants()) do
        if d:IsA('BasePart') then
            _ApplyMaterialToPart(d)
        end
    end
    -- Отслеживаем новые объекты
    V.Textures.Connections.DescAdded = V.WS.DescendantAdded:Connect(function(d)
        if d and d:IsA('BasePart') then
            _ApplyMaterialToPart(d)
        end
    end)
end

function DisableTextures()
    -- Отключаем коннекты
    for k, conn in pairs(V.Textures.Connections) do
        if typeof(conn) == 'RBXScriptConnection' then conn:Disconnect() end
        V.Textures.Connections[k] = nil
    end
    -- Восстанавливаем оригинальные материалы
    if V.Textures.Originals then
        for inst, mat in pairs(V.Textures.Originals) do
            if inst and inst.Parent then
                inst.Material = mat
            end
        end
    end
    -- Держим таблицу как пустую, чтобы удовлетворить узкую типизацию Luau
    V.Textures.Originals = {}
end

-- UI: Textures
-- Подготовим список материалов заранее с безопасным фолбэком
if not V.MaterialList then
    V.Temp.TempTable = {}
    local ok, items = pcall(function() return Enum.Material:GetEnumItems() end)
    if ok and items then
        for _, m in ipairs(items) do
            table.insert(V.Temp.TempTable, m.Name)
        end
    else
        -- Фолбэк на базовый набор, если по какой-то причине Enum недоступен
        V.Temp.TempTable = {'Plastic','Wood','Slate','Concrete','CorrodedMetal','DiamondPlate','Foil','Grass','Ice','Marble','Granite','Brick','Pebble','Sand','Fabric','SmoothPlastic','Metal','WoodPlanks','Cobblestone','Rock','Glass','Asphalt'}
    end
    V.MaterialList = V.Temp.TempTable
end

local TexturesBox = V.Tabs.Visuals:AddLeftGroupbox('Textures')
local _TexturesToggle = TexturesBox:AddToggle('TexturesEnabled', {
    Text = 'Enabled',
    Default = Config.Textures.Enabled,
    Tooltip = 'Применять материал ко всем объектам, кроме игроков',
    Callback = function(v)
        Config.Textures.Enabled = v
        if v then EnableTextures() else DisableTextures() end
    end
})

-- Дропдаун материалов (инициализируется при открытии)
TexturesBox:AddDropdown('TexturesMaterial', {
    Values = V.MaterialList,
    Default = Config.Textures.Selected,
    Multi = false,
    Text = 'Material',
    Callback = function(val)
        Config.Textures.Selected = val
        if Config.Textures.Enabled then
            -- Пере-применяем к уже обработанным (и новым через коннект)
            if V.Textures.Originals then
                for inst, _ in pairs(V.Textures.Originals) do
                    if inst and inst.Parent then
                        _ApplyMaterialToPart(inst)
                    end
                end
            end
        end
    end
})

-- Автоинициализация, если было включено в конфиг
if Config.Textures.Enabled then
    EnableTextures()
end

JumpCirclesBox:AddSlider('JumpCirclesLifeAfterMax', {
    Text = 'Жизнь после максимума (сек)',
    Min = 0, Max = 2, Rounding = 2, Compact = true,
    Default = Config.JumpCircles.LifeAfterMax,
    Callback = function(v)
        Config.JumpCircles.LifeAfterMax = v
    end
})

--================ NAME TAGS SYSTEM ===============--
-- Гарантируем наличие конфигурации
if not Config.NameTags then
    Config.NameTags = {
        Enabled = false,
        Color = Color3.new(1, 1, 1),
        BackgroundTransparency = 1,
        Scale = 0.8,
        Font = Enum.Font.SourceSans,
        ShowHealth = false,
        ShowDistance = false,
        UseDisplayName = true,
        DistanceCheck = false,
        DistanceMin = 0,
        DistanceMax = 64,
    }
end

V.NameTags = {}
V.NameTagsConnections = {}
-- RunService уже кеширован в V.RS

local function CreateNameTag(player)
    if not player.Character then return nil end
    local head = player.Character:FindFirstChild('Head')
    if not head then return nil end
    local bb = Instance.new('BillboardGui')
    bb.Name = 'NameTag'
    bb.Adornee = head
    bb.Size = UDim2.new(0, 200, 0, 30)
            bb.StudsOffset = Vector3.new(0, 1.5, 0)
    bb.AlwaysOnTop = true
    V.TempNameLabel = Instance.new('TextLabel')
    V.TempNameLabel.Size = UDim2.new(1, 0, 1, 0)
    V.TempNameLabel.BackgroundTransparency = Config.NameTags.BackgroundTransparency
    V.TempNameLabel.BackgroundColor3 = Color3.new()
    V.TempNameLabel.BorderSizePixel = 0
    V.TempNameLabel.Font = Enum.Font.SourceSansBold
    V.TempNameLabel.TextScaled = false   
    V.TempNameLabel.Font = Config.NameTags.Font
    V.TempNameLabel.TextSize = 14 * Config.NameTags.Scale
    V.TempNameLabel.TextStrokeTransparency = 0.5
    V.TempNameLabel.TextColor3 = Config.NameTags.Color
        V.TempNameLabel.Text = Config.NameTags.UseDisplayName and player.DisplayName or player.Name
    V.TempNameLabel.Parent = bb
        -- Hide default Roblox overhead names
    if player.Character and player.Character:FindFirstChild('Humanoid') then
            local hum = player.Character.Humanoid
        hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        -- If Roblox suddenly re-enables name display (e.g., after death), immediately disable
        if V.NameTagsConnections["HumanoidDDT_"..player.UserId] then
            V.NameTagsConnections["HumanoidDDT_"..player.UserId]:Disconnect()
        end
        V.NameTagsConnections["HumanoidDDT_"..player.UserId] = hum:GetPropertyChangedSignal("DisplayDistanceType"):Connect(function()
            local humanoid = player.Character.Humanoid
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        end)
        -- При смерти тоже убеждаемся, что ник не появится
        hum.Died:Connect(function()
            hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
        end)
    end
    bb.Parent = head
    return bb
end

local function UpdateNameTag(bb, player, distance)
    V.TempNameLabel = bb and bb:FindFirstChildOfClass('TextLabel')
    if not V.TempNameLabel then return end
    V.NameTagParts = V.NameTagParts or {}
    table.clear(V.NameTagParts)
    if Config.NameTags.ShowDistance then table.insert(V.NameTagParts, string.format('[%dm]', distance)) end
    table.insert(V.NameTagParts, Config.NameTags.UseDisplayName and player.DisplayName or player.Name)
    if Config.NameTags.ShowHealth and player.Character and player.Character:FindFirstChildOfClass('Humanoid') then
        table.insert(V.NameTagParts, '{'..math.floor(player.Character.Humanoid.Health)..'}')
    end
    V.TempNameLabel.Text = table.concat(V.NameTagParts, ' ')
    -- Динамический подъём неймтега, чтобы быть над Box ESP
        local dynOffsetY = math.clamp(distance / 25, 1.5, 6)
    if bb then bb.StudsOffset = Vector3.new(0, dynOffsetY, 0) end
    V.TempNameLabel.TextColor3 = Config.NameTags.Color
    V.TempNameLabel.BackgroundTransparency = Config.NameTags.BackgroundTransparency
    V.TempNameLabel.TextSize = 14 * Config.NameTags.Scale
    V.TempNameLabel.Font = Config.NameTags.Font
end

local function RemoveNameTag(player)
    if V.NameTags[player] then
        V.NameTags[player]:Destroy()
        V.NameTags[player] = nil
    end
end

-- Utility: hide default Roblox overhead names
local function HideDefaultNames(enable)
    pcall(function()
        for _, plr in ipairs(V.Players:GetPlayers()) do
            if plr.Character and plr.Character:FindFirstChild('Humanoid') then
                V.TempHumanoid = plr.Character.Humanoid
                if enable then
                    V.TempHumanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                else
                    V.TempHumanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                end
            end
        end
    end)
end

local function EnableNameTags()
    if not Config.NameTags.Enabled then return end
    for _, plr in ipairs(V.Players:GetPlayers()) do
        if plr ~= V.LP then
            local bb = CreateNameTag(plr)
            if bb then V.NameTags[plr] = bb end
        end
    end
    V.NameTagsConnections.PlayerAdded = V.Players.PlayerAdded:Connect(function(plr)
        V.NameTagsConnections[plr] = plr.CharacterAdded:Connect(function(char)
            if Config.NameTags.Enabled then
                RemoveNameTag(plr)
                local bb = CreateNameTag(plr)
                if bb then V.NameTags[plr] = bb end
            end
        end)
    end)
    for _, plr in ipairs(V.Players:GetPlayers()) do
        if plr ~= V.LP then
            V.NameTagsConnections[plr] = plr.CharacterAdded:Connect(function(char)
                -- Скрываем стандартный ник при каждом респавне
                task.defer(function()
                    if char and char:FindFirstChild('Humanoid') then
                        char.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                    end
                end)
                if Config.NameTags.Enabled then
                    RemoveNameTag(plr)
                    local bb = CreateNameTag(plr)
                    if bb then V.NameTags[plr] = bb end
                end
            end)
        end
    end
    HideDefaultNames(true)

    V.NameTagsConnections.Render = V.RS.RenderStepped:Connect(function()
        if not Config.NameTags.Enabled then return end
        local lpChar = V.LP.Character
        if not lpChar or not lpChar:FindFirstChild('HumanoidRootPart') then return end
        local lpPos = lpChar.HumanoidRootPart.Position
        for _, plr in ipairs(V.Players:GetPlayers()) do
            if plr ~= V.LP and plr.Character and plr.Character:FindFirstChild('HumanoidRootPart') then
                local dist = (lpPos - plr.Character.HumanoidRootPart.Position).Magnitude
                if Config.NameTags.DistanceCheck and (dist < Config.NameTags.DistanceMin or dist > Config.NameTags.DistanceMax) then
                    RemoveNameTag(plr)
                else
                    if not V.NameTags[plr] then
                        local bb = CreateNameTag(plr)
                        if bb then V.NameTags[plr] = bb end
                    end
                    if V.NameTags[plr] then
                        UpdateNameTag(V.NameTags[plr], plr, math.floor(dist))
                    end
                end
            end
        end
    end)
end

local function DisableNameTags()
    for plr in pairs(V.NameTags) do
        RemoveNameTag(plr)
    end
    for _, conn in pairs(V.NameTagsConnections) do
        if typeof(conn) == 'RBXScriptConnection' then conn:Disconnect() end
    end
    V.NameTagsConnections = {}
    HideDefaultNames(false)
end

-- NAME TAGS UI
local NameTagsBox = V.Tabs.Visuals:AddLeftGroupbox('NameTags')

local NameTagsToggle = NameTagsBox:AddToggle('NameTagsEnabled', {
    Text = 'Enabled',
    Default = Config.NameTags.Enabled,
    Tooltip = 'Показывает имена игроков сквозь стены',
    Callback = function(v)
        Config.NameTags.Enabled = v
        if v then EnableNameTags() else DisableNameTags() end
    end
})

-- Цвет текста
NameTagsToggle:AddColorPicker('NameTagsColor', {
    Default = Config.NameTags.Color,
    Title = 'Text Color',
    Transparency = false,
    Callback = function(c)
        Config.NameTags.Color = c
        if Config.NameTags.Enabled then DisableNameTags(); EnableNameTags() end
    end
})

-- Выбор шрифта
NameTagsBox:AddDropdown('NameTagsFont', {
    Values = {'SourceSans','Arial','ArialBold','SourceSansBold','Gotham','GothamBold','Legacy'},
    Default = 1,
    Tooltip = 'Font',
    Callback = function(v)
        local success, enumFont = pcall(function() return Enum.Font[v] end)
        if success then
            Config.NameTags.Font = enumFont
            if Config.NameTags.Enabled then DisableNameTags(); EnableNameTags() end
        end
    end
})

-- Показать здоровье
NameTagsBox:AddToggle('NameTagsShowHealth', {
    Text = 'Show Health',
    Default = Config.NameTags.ShowHealth,
    Callback = function(v)
        Config.NameTags.ShowHealth = v
        if Config.NameTags.Enabled then DisableNameTags(); EnableNameTags() end
    end
})

-- Показать дистанцию
NameTagsBox:AddToggle('NameTagsShowDistance', {
    Text = 'Show Distance',
    Default = Config.NameTags.ShowDistance,
    Callback = function(v)
        Config.NameTags.ShowDistance = v
        if Config.NameTags.Enabled then DisableNameTags(); EnableNameTags() end
    end
})

-- Использовать DisplayName
NameTagsBox:AddToggle('NameTagsUseDisplayName', {
    Text = 'Use DisplayName',
    Default = Config.NameTags.UseDisplayName,
    Callback = function(v)
        Config.NameTags.UseDisplayName = v
        if Config.NameTags.Enabled then DisableNameTags(); EnableNameTags() end
    end
})

-- Инициализация при загрузке
if Config.MaterialChams.Enabled then EnableMaterialChams() end
if Config.SelfMaterial.Enabled then EnableSelfMaterial() end
if Config.SelfAccessoryMaterial.Enabled then EnableSelfAccessoryMaterial() end
if Config.NameTags.Enabled then EnableNameTags() end
if Config.JumpCircles and Config.JumpCircles.Enabled then EnableJumpCircles() end

-- CONE HAT SYSTEM
local function InitializeConeHat()
    -- Создаем рисунки для конуса
    for i = 1, Config.ConeHat.Sides do
        V.ConeHatDrawings[i] = {
            Drawing.new("Line"),     -- Линия для круга
            Drawing.new("Triangle")  -- Треугольник для шляпы
        }
        V.ConeHatDrawings[i][1].ZIndex = 2
        V.ConeHatDrawings[i][1].Thickness = 2
        V.ConeHatDrawings[i][2].ZIndex = 1
        V.ConeHatDrawings[i][2].Filled = true
    end
end

local function UpdateConeHat()
    local pass = Config.ConeHat.Enabled and 
                V.LP.Character and 
                V.LP.Character:FindFirstChild("Head") ~= nil and
                (V.Cam.CFrame.p - V.Cam.Focus.p).Magnitude > Config.ConeHat.MinCameraDistance and
                V.LP.Character:FindFirstChild("Humanoid") and
                V.LP.Character.Humanoid.Health > 0
                
    for i = 1, #V.ConeHatDrawings do
        local line, triangle = V.ConeHatDrawings[i][1], V.ConeHatDrawings[i][2]
        if pass then
            local color
            
            if Config.ConeHat.ColorMode == 'Rainbow' then
                -- Радужный режим
                color = Color3.fromHSV((tick() % 5 / 5 - (i / #V.ConeHatDrawings)) % 1, 0.5, 1)
            else
                -- Custom режим с анимированным градиентом (вращается подобно радужному)
                local progress = i / #V.ConeHatDrawings
                -- Смещаем прогресс во времени, чтобы градиент «крутился»
                local shift = (tick() % 5) / 5 -- Период 5 секунд; меняйте при желании
                local phase = (progress + shift) % 1

                if phase < 0.33 then
                    -- Интерполяция между Color1 и Color2
                    local t = phase / 0.33
                    color = Config.ConeHat.GradientColor1:Lerp(Config.ConeHat.GradientColor2, t)
                elseif phase < 0.66 then
                    -- Интерполяция между Color2 и Color3
                    local t = (phase - 0.33) / 0.33
                    color = Config.ConeHat.GradientColor2:Lerp(Config.ConeHat.GradientColor3, t)
                else
                    -- Интерполяция между Color3 и Color1 (замыкание круга)
                    local t = (phase - 0.66) / 0.34
                    color = Config.ConeHat.GradientColor3:Lerp(Config.ConeHat.GradientColor1, t)
                end
            end
                         
            local pos = V.LP.Character.Head.Position + Config.ConeHat.Offset
            local topWorld = pos + V.V3(0, Config.ConeHat.Height, 0)
            
            local tau = math.pi * 2
            local last = (i / Config.ConeHat.Sides) * tau
            local next = ((i + 1) / Config.ConeHat.Sides) * tau
            
            local lastWorld = pos + (V.V3(math.cos(last), 0, math.sin(last)) * Config.ConeHat.Radius)
            local nextWorld = pos + (V.V3(math.cos(next), 0, math.sin(next)) * Config.ConeHat.Radius)
            
            local lastScreen = V.Cam:WorldToViewportPoint(lastWorld)
            local nextScreen = V.Cam:WorldToViewportPoint(nextWorld)
            local topScreen = V.Cam:WorldToViewportPoint(topWorld)
            
            line.From = V.V2(lastScreen.X, lastScreen.Y)
            line.To = V.V2(nextScreen.X, nextScreen.Y)
            line.Color = color
            line.Transparency = Config.ConeHat.CircleTransparency
            line.Visible = true
            
            triangle.PointA = V.V2(topScreen.X, topScreen.Y)
            triangle.PointB = line.From
            triangle.PointC = line.To
            triangle.Color = color
            triangle.Transparency = Config.ConeHat.HatTransparency
            triangle.Visible = true
        else
            line.Visible = false
            triangle.Visible = false
        end
    end
end

local function EnableConeHat()
    if not V.ConeHatDrawings or #V.ConeHatDrawings == 0 then
        InitializeConeHat()
    end
    
    if V.ConeHatConnection then
        V.ConeHatConnection:Disconnect()
    end
    
    V.ConeHatConnection = V.RS.RenderStepped:Connect(UpdateConeHat)
end

local function DisableConeHat()
    if V.ConeHatConnection then
        V.ConeHatConnection:Disconnect()
        V.ConeHatConnection = nil
    end
    
    -- Скрываем все рисунки
    for i = 1, #V.ConeHatDrawings do
        if V.ConeHatDrawings[i] then
            V.ConeHatDrawings[i][1].Visible = false
            V.ConeHatDrawings[i][2].Visible = false
        end
    end
end

local function UpdateConeHatSides()
    -- Удаляем старые рисунки
    for i = 1, #V.ConeHatDrawings do
        if V.ConeHatDrawings[i] then
            V.ConeHatDrawings[i][1]:Remove()
            V.ConeHatDrawings[i][2]:Remove()
        end
    end
    V.ConeHatDrawings = {}
    
    -- Создаем новые с обновленным количеством сторон
    InitializeConeHat()
end

--================ CROSSHAIR SYSTEM ================--
local function GenerateCrosshairAngles(numLines)
    V.Crosshair.LineOffsets = {}
    local angleIncrement = 2 * math.pi / numLines
    
    for i = 1, numLines do
        V.Crosshair.LineOffsets[i] = (i - 1) * angleIncrement
    end
end

local function CreateCrosshair()
    -- Очищаем старые линии
    for i = 1, #V.Crosshair.Lines do
        if V.Crosshair.Lines[i] then
            V.Crosshair.Lines[i]:Remove()
        end
        if V.Crosshair.Outlines[i] then
            V.Crosshair.Outlines[i]:Remove()
        end
    end
    V.Crosshair.Lines = {}
    V.Crosshair.Outlines = {}
    
    -- Создаем линии прицела
    for i = 1, Config.Crosshair.Sides do
        V.Crosshair.Lines[i] = V.Drawing.new("Line")
        V.Crosshair.Lines[i].Visible = false
        V.Crosshair.Lines[i].Color = Config.Crosshair.CrosshairColor
        V.Crosshair.Lines[i].Thickness = Config.Crosshair.Thickness
        V.Crosshair.Lines[i].ZIndex = 2
        V.Crosshair.Lines[i].Transparency = 1
        
        V.Crosshair.Outlines[i] = V.Drawing.new("Line")
        V.Crosshair.Outlines[i].Visible = false
        V.Crosshair.Outlines[i].Color = Config.Crosshair.OutlineColor
        V.Crosshair.Outlines[i].Thickness = Config.Crosshair.Thickness + 1
        V.Crosshair.Outlines[i].ZIndex = 1
        V.Crosshair.Outlines[i].Transparency = 1
    end
    
    -- Генерируем углы
    GenerateCrosshairAngles(Config.Crosshair.Sides)
    
    -- Создаем текст если включен
    if Config.Crosshair.ShowText then
        if V.Crosshair.TextMain then V.Crosshair.TextMain:Remove() end
        V.Crosshair.TextMain = V.Drawing.new("Text")
        V.Crosshair.TextMain.Outline = true
        V.Crosshair.TextMain.Text = "simple.lua"
        V.Crosshair.TextMain.Color = Config.Crosshair.TextColor
        V.Crosshair.TextMain.Size = 18 -- чуть меньше
        V.Crosshair.TextMain.Visible = false
        V.Crosshair.TextMain.Font = 2
    end
end

local function UpdateCrosshair()
    if not Config.Crosshair.Enabled then
        -- Скрываем прицел
        for i = 1, #V.Crosshair.Lines do
            if V.Crosshair.Lines[i] then
                V.Crosshair.Lines[i].Visible = false
            end
            if V.Crosshair.Outlines[i] then
                V.Crosshair.Outlines[i].Visible = false
            end
        end
        if V.Crosshair.TextMain then
            V.Crosshair.TextMain.Visible = false
        end
        return
    end
    
    -- Выбираем точку привязки: цель или мышь
    if Config.Crosshair.AttachToTarget and V.Target and V.Target.player and V.Target.player.Character then
        local char = V.Target.player.Character
        local hrp = char:FindFirstChild('HumanoidRootPart')
        if hrp then
            local sp, onScr = V.Cam:WorldToViewportPoint(hrp.Position)
            if onScr then
                V.Crosshair.TempMousePos = Vector2.new(sp.X, sp.Y)
            else
                V.Crosshair.TempMousePos = V.UIS:GetMouseLocation()
            end
        else
            V.Crosshair.TempMousePos = V.UIS:GetMouseLocation()
        end
    else
        V.Crosshair.TempMousePos = V.UIS:GetMouseLocation()
    end
    
    -- Обновляем угол вращения
    if Config.Crosshair.AlwaysRotating then
        V.Crosshair.SpinAngle = V.Crosshair.SpinAngle + math.rad((Config.Crosshair.Speed * 10) * (1/60))
    else
        V.Crosshair.SpinAngle = 0
    end
    
    -- Вычисляем свойства прицела
    V.Crosshair.TempRadius = Config.Crosshair.Length * 5
    local Gap = Config.Crosshair.GapSize
    
    -- Обновляем размер курсора для эффекта пульсации
    V.Crosshair.CursorSize = V.Crosshair.CursorSize + 0.025
    
    local LocalRadius = V.Crosshair.TempRadius
    if Config.Crosshair.Pulse then
        local Dynamic = math.cos(V.Crosshair.CursorSize)
        LocalRadius = V.Crosshair.TempRadius - (V.Crosshair.TempRadius / 4) * math.abs(Dynamic)
    end
    
    -- Обновляем линии прицела
    for i = 1, #V.Crosshair.Lines do
        if V.Crosshair.Lines[i] and V.Crosshair.LineOffsets[i] then
            V.Crosshair.TempAngle = V.Crosshair.SpinAngle + V.Crosshair.LineOffsets[i]
            V.Crosshair.TempDirection = Vector2.new(
                math.cos(V.Crosshair.TempAngle),
                math.sin(V.Crosshair.TempAngle)
            ).Unit
            
            -- Устанавливаем позиции линий
            V.Crosshair.Lines[i].From = V.Crosshair.TempMousePos + V.Crosshair.TempDirection * Gap
            V.Crosshair.Lines[i].To = V.Crosshair.Lines[i].From + V.Crosshair.TempDirection * LocalRadius
            V.Crosshair.Lines[i].Visible = true
            V.Crosshair.Lines[i].Color = Config.Crosshair.CrosshairColor
            V.Crosshair.Lines[i].Thickness = Config.Crosshair.Thickness
            
            -- Устанавливаем позиции контуров
            if V.Crosshair.Outlines[i] then
                V.Crosshair.Outlines[i].From = V.Crosshair.TempMousePos + V.Crosshair.TempDirection * (Gap - 1)
                V.Crosshair.Outlines[i].To = V.Crosshair.Lines[i].From + V.Crosshair.TempDirection * (LocalRadius + 1)
                V.Crosshair.Outlines[i].Visible = true
                V.Crosshair.Outlines[i].Color = Config.Crosshair.OutlineColor
                V.Crosshair.Outlines[i].Thickness = Config.Crosshair.Thickness + 1
            end
        end
    end
    
    -- Обновляем текст если включен
    if Config.Crosshair.ShowText and V.Crosshair.TextMain then
        local yOffset = (Config.Crosshair.Length * 5) + Config.Crosshair.GapSize + 15
        local tb = V.Crosshair.TextMain.TextBounds or Vector2.new(0, 0)
        V.Crosshair.TextMain.Position = Vector2.new(
            V.Crosshair.TempMousePos.X - (tb.X / 2),
            V.Crosshair.TempMousePos.Y + yOffset
        )
        V.Crosshair.TextMain.Visible = true
        V.Crosshair.TextMain.Color = Config.Crosshair.TextColor
        
        -- Применяем эффект пульсации
        if Config.Crosshair.Pulse then
            local sine = math.abs(math.sin(tick() * 4))
            V.Crosshair.TextMain.Transparency = sine
        else
            V.Crosshair.TextMain.Transparency = 1
        end
    end
end

local function EnableCrosshair()
    CreateCrosshair()
    if V.Crosshair.Connection then
        V.Crosshair.Connection:Disconnect()
    end
    V.Crosshair.Connection = V.RS.RenderStepped:Connect(UpdateCrosshair)
end

local function DisableCrosshair()
    if V.Crosshair.Connection then
        V.Crosshair.Connection:Disconnect()
        V.Crosshair.Connection = nil
    end
    UpdateCrosshair() -- Вызываем для скрытия
end

local function UpdateCrosshairSides()
    if Config.Crosshair.Enabled then
        CreateCrosshair()
    end
end

-- CROSSHAIR UI
local CrosshairBox = V.Tabs.Visuals:AddLeftGroupbox('Crosshair')

-- Toggle для включения
local CrosshairToggle = CrosshairBox:AddToggle('CrosshairEnabled', {
    Text = 'Enabled',
    Default = Config.Crosshair.Enabled,
    Callback = function(v)
        Config.Crosshair.Enabled = v
        if v then
            EnableCrosshair()
        else
            DisableCrosshair()
        end
    end
})

-- Color picker для цвета прицела
CrosshairToggle:AddColorPicker('CrosshairColor', {
    Default = Config.Crosshair.CrosshairColor,
    Title = 'Color',
    Callback = function(c)
        Config.Crosshair.CrosshairColor = c
    end
})

-- Слайдер для длины
CrosshairBox:AddSlider('CrosshairLength', {
    Text = 'Length',
    Min = 5,
    Max = 50,
    Rounding = 0,
    Compact = true,
    Default = Config.Crosshair.Length,
    Callback = function(v)
        Config.Crosshair.Length = v
    end
})

-- Слайдер для зазора
CrosshairBox:AddSlider('CrosshairGapSize', {
    Text = 'Gap Size',
    Min = 0,
    Max = 50,
    Rounding = 0,
    Compact = true,
    Default = Config.Crosshair.GapSize,
    Callback = function(v)
        Config.Crosshair.GapSize = v
    end
})

-- Слайдер для толщины
CrosshairBox:AddSlider('CrosshairThickness', {
    Text = 'Thickness',
    Min = 1,
    Max = 10,
    Rounding = 1,
    Compact = true,
    Default = Config.Crosshair.Thickness,
    Callback = function(v)
        Config.Crosshair.Thickness = v
    end
})

-- Слайдер для количества сторон
CrosshairBox:AddSlider('CrosshairSides', {
    Text = 'Sides',
    Min = 2,
    Max = 8,
    Rounding = 0,
    Compact = true,
    Default = Config.Crosshair.Sides,
    Callback = function(v)
        Config.Crosshair.Sides = v
        UpdateCrosshairSides()
    end
})

-- Toggle для вращения
CrosshairBox:AddToggle('CrosshairRotating', {
    Text = 'Always Rotating',
    Default = Config.Crosshair.AlwaysRotating,
    Callback = function(v)
        Config.Crosshair.AlwaysRotating = v
    end
})

-- Слайдер для скорости вращения
CrosshairBox:AddSlider('CrosshairSpeed', {
    Text = 'Rotation Speed',
    Min = 0,
    Max = 20,
    Rounding = 1,
    Compact = true,
    Default = Config.Crosshair.Speed,
    Callback = function(v)
        Config.Crosshair.Speed = v
    end
})

-- Toggle для пульсации
CrosshairBox:AddToggle('CrosshairPulse', {
    Text = 'Pulse Effect',
    Default = Config.Crosshair.Pulse,
    Callback = function(v)
        Config.Crosshair.Pulse = v
    end
})

-- Toggle для привязки к цели
CrosshairBox:AddToggle('CrosshairAttach', {
    Text = 'Attach to target',
    Default = Config.Crosshair.AttachToTarget,
    Callback = function(v)
        Config.Crosshair.AttachToTarget = v
    end
})

-- Toggle для текста
local CrosshairTextToggle = CrosshairBox:AddToggle('CrosshairShowText', {
    Text = 'Show Text',
    Default = Config.Crosshair.ShowText,
    Callback = function(v)
        Config.Crosshair.ShowText = v
        if v and not V.Crosshair.TextMain then
            CreateCrosshair()
        elseif not v and V.Crosshair.TextMain then
            V.Crosshair.TextMain.Visible = false
        end
    end
})

-- Color picker для цвета текста
CrosshairTextToggle:AddColorPicker('CrosshairTextColor', {
    Default = Config.Crosshair.TextColor,
    Title = 'Text Color',
    Callback = function(c)
        Config.Crosshair.TextColor = c
    end
})

-- Toggle для контура
local CrosshairOutlineToggle = CrosshairBox:AddToggle('CrosshairOutline', {
    Text = 'Show Outline',
    Default = true,
    Callback = function(v)
        for i = 1, #V.Crosshair.Outlines do
            if V.Crosshair.Outlines[i] then
                V.Crosshair.Outlines[i].Visible = v and Config.Crosshair.Enabled
            end
        end
    end
})

-- Color picker для цвета контура
CrosshairOutlineToggle:AddColorPicker('CrosshairOutlineColor', {
    Default = Config.Crosshair.OutlineColor,
    Title = 'Outline Color',
    Callback = function(c)
        Config.Crosshair.OutlineColor = c
    end
})

-- Инициализация при загрузке
if Config.Crosshair.Enabled then
    EnableCrosshair()
end

-- CONE HAT UI
local ConeHatBox = V.Tabs.Visuals:AddLeftGroupbox('Cone Hat')

-- Toggle для включения/выключения
local ConeHatToggle = ConeHatBox:AddToggle('ConeHatEnabled', {
    Text = 'Enabled',
    Default = Config.ConeHat.Enabled,
    Callback = function(Value)
        Config.ConeHat.Enabled = Value
        if Value then
            EnableConeHat()
        else
            DisableConeHat()
        end
    end
})

-- Dropdown для выбора режима цвета
local ConeHatColorMode = ConeHatBox:AddDropdown('ConeHatColorMode', {
    Values = {'Custom', 'Rainbow'},
    Default = Config.ConeHat.ColorMode,
    Multi = false,
    Text = 'Color Type',
    Callback = function(Value)
        Config.ConeHat.ColorMode = Value
    end
})

-- Три цвета для градиента (только для Custom режима)
local ConeHatColor1 = ConeHatBox:AddLabel('Gradient Color 1')
    :AddColorPicker('ConeHatGradient1', {
        Default = Config.ConeHat.GradientColor1,
        Title = 'Gradient Start',
        Callback = function(Value)
            Config.ConeHat.GradientColor1 = Value
        end
    })

local ConeHatColor2 = ConeHatBox:AddLabel('Gradient Color 2')
    :AddColorPicker('ConeHatGradient2', {
        Default = Config.ConeHat.GradientColor2,
        Title = 'Gradient Middle',
        Callback = function(Value)
            Config.ConeHat.GradientColor2 = Value
        end
    })

local ConeHatColor3 = ConeHatBox:AddLabel('Gradient Color 3')
    :AddColorPicker('ConeHatGradient3', {
        Default = Config.ConeHat.GradientColor3,
        Title = 'Gradient End',
        Callback = function(Value)
            Config.ConeHat.GradientColor3 = Value
        end
    })

-- Слайдер для высоты
local ConeHatHeight = ConeHatBox:AddSlider('ConeHatHeight', {
    Text = 'Height',
    Default = Config.ConeHat.Height,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(Value)
        Config.ConeHat.Height = Value
    end
})

-- Слайдер для радиуса
local ConeHatRadius = ConeHatBox:AddSlider('ConeHatRadius', {
    Text = 'Radius',
    Default = Config.ConeHat.Radius,
    Min = 0.1,
    Max = 3,
    Rounding = 2,
    Callback = function(Value)
        Config.ConeHat.Radius = Value
    end
})

-- Слайдер для прозрачности круга
local ConeHatCircleTransparency = ConeHatBox:AddSlider('ConeHatCircleTransparency', {
    Text = 'Circle Transparency',
    Default = Config.ConeHat.CircleTransparency,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Callback = function(Value)
        Config.ConeHat.CircleTransparency = Value
    end
})

-- Инициализация Cone Hat при загрузке
if Config.ConeHat.Enabled then
    EnableConeHat()
end

-- BOXES ESP SYSTEM
local function CreateBoxESP(player)
    local Box = {
        Main = Drawing.new("Square"),
        Outline = Drawing.new("Square"),
        HealthBar = {
            Main = Drawing.new("Square"),
            Outline = Drawing.new("Square")
        }
    }
    
    -- Main box
    Box.Main.Visible = false
    Box.Main.Color = Config.Boxes.Color
    Box.Main.Thickness = Config.Boxes.Thickness
    Box.Main.Filled = false
    Box.Main.ZIndex = 2
    
    -- Outline
    Box.Outline.Visible = false
    Box.Outline.Color = Color3.new(0, 0, 0)
    Box.Outline.Thickness = Config.Boxes.Thickness + 0.1
    Box.Outline.Filled = false
    Box.Outline.ZIndex = 1
    
    -- HealthBar
    Box.HealthBar.Main.Visible = false
    Box.HealthBar.Main.Color = Config.Boxes.HealthBarColor
    Box.HealthBar.Main.Thickness = 1
    Box.HealthBar.Main.Filled = true
    Box.HealthBar.Main.ZIndex = 3
    
    Box.HealthBar.Outline.Visible = false
    Box.HealthBar.Outline.Color = Config.Boxes.HealthBarBgColor
    Box.HealthBar.Outline.Thickness = 1
    Box.HealthBar.Outline.Filled = true
    Box.HealthBar.Outline.ZIndex = 2
    
    V.BoxesCache[player] = Box
    return Box
end

local function UpdateBoxESP(player)
    if not V.BoxesCache[player] then return end
    
    local character = player.Character
    if not character then
        V.BoxesCache[player].Main.Visible = false
        V.BoxesCache[player].Outline.Visible = false
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
        return
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        V.BoxesCache[player].Main.Visible = false
        V.BoxesCache[player].Outline.Visible = false
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
        return
    end
    
    local rootPart = character:FindFirstChild('HumanoidRootPart')
    
    if not (rootPart and humanoid) then
        V.BoxesCache[player].Main.Visible = false
        V.BoxesCache[player].Outline.Visible = false
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
        return
    end
    
    -- Check distance before doing any rendering
    local localChar = V.LP.Character
    local localRoot = localChar and localChar:FindFirstChild('HumanoidRootPart')
    if not localRoot then return end
    
    local distance = (rootPart.Position - localRoot.Position).Magnitude
    if distance > Config.Boxes.MaxDistance then
        V.BoxesCache[player].Main.Visible = false
        V.BoxesCache[player].Outline.Visible = false
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
        return
    end
    
    V.ScreenPoint, V.OnScreen = V.Cam:WorldToViewportPoint(rootPart.Position)
    
    if not V.OnScreen then
        V.BoxesCache[player].Main.Visible = false
        V.BoxesCache[player].Outline.Visible = false
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
        return
    end
    
    -- Calculate character bounds
    local minX, maxX = math.huge, -math.huge
    local minY, maxY = math.huge, -math.huge
    local validParts = 0
    
    -- Если игрок в состоянии KO, используем упрощённый бокс (только HRP)
    if IsPlayerKO(player) then
        validParts = 0
    else
        for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") and part ~= rootPart then
            local partPos, partVis = V.Cam:WorldToViewportPoint(part.Position)
            if partVis then
                -- Calculate part bounds with size consideration
                local partSize = part.Size
                local halfX = (partSize.X * 50) / partPos.Z -- Scale factor for screen space
                local halfY = (partSize.Y * 50) / partPos.Z
                
                minX = math.min(minX, partPos.X - halfX)
                maxX = math.max(maxX, partPos.X + halfX)
                minY = math.min(minY, partPos.Y - halfY)
                maxY = math.max(maxY, partPos.Y + halfY)
                validParts = validParts + 1
            end
        end
        end
    end
    
    -- Fallback to root part если в KO или не найдено валидных частей
    if validParts == 0 then
        V.ScreenPoint, V.OnScreen = V.Cam:WorldToViewportPoint(rootPart.Position)
        if not V.OnScreen then
            V.BoxesCache[player].Main.Visible = false
            V.BoxesCache[player].Outline.Visible = false
            V.BoxesCache[player].HealthBar.Main.Visible = false
            V.BoxesCache[player].HealthBar.Outline.Visible = false
            return
        end
        -- Use fallback sizing
        local fallbackSize = V.V2(
            math.floor(2200 / V.ScreenPoint.Z),
            math.floor(3200 / V.ScreenPoint.Z)
        )
        minX = V.ScreenPoint.X - fallbackSize.X / 2
        maxX = V.ScreenPoint.X + fallbackSize.X / 2
        minY = V.ScreenPoint.Y - fallbackSize.Y / 2
        maxY = V.ScreenPoint.Y + fallbackSize.Y / 2
    end
    
    -- Add padding
    local padding = 5
    minX = minX - padding
    maxX = maxX + padding
    minY = minY - padding
    maxY = maxY + padding
    
    -- Calculate final box dimensions
    local size = Vector2.new(
        math.floor(maxX - minX),
        math.floor(maxY - minY)
    )
    
    local boxPosition = Vector2.new(
        math.floor(minX),
        math.floor(minY)
    )
    
    -- Update main box
    V.BoxesCache[player].Main.Visible = Config.Boxes.Enabled
    V.BoxesCache[player].Main.Position = boxPosition
    V.BoxesCache[player].Main.Size = size
    V.BoxesCache[player].Main.Color = Config.Boxes.Color
    V.BoxesCache[player].Main.Thickness = Config.Boxes.Thickness
    V.BoxesCache[player].Main.Filled = false
    
    V.BoxesCache[player].Outline.Visible = Config.Boxes.Enabled
    V.BoxesCache[player].Outline.Position = boxPosition - Vector2.new(1, 1)
    V.BoxesCache[player].Outline.Size = size + Vector2.new(2, 2)
    
    -- Update HealthBar
    if Config.Boxes.HealthBarEnabled and Config.Boxes.Enabled then
        local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
        local healthBarHeight = math.floor(size.Y * healthPercent)
        
        local healthBarPosition = boxPosition - Vector2.new(Config.Boxes.HealthBarWidth + 4, 0)
        
        V.BoxesCache[player].HealthBar.Outline.Visible = true
        V.BoxesCache[player].HealthBar.Outline.Position = healthBarPosition
        V.BoxesCache[player].HealthBar.Outline.Size = Vector2.new(Config.Boxes.HealthBarWidth, size.Y + 1)
        V.BoxesCache[player].HealthBar.Outline.Color = Config.Boxes.HealthBarBgColor
        
        V.BoxesCache[player].HealthBar.Main.Visible = true
        V.BoxesCache[player].HealthBar.Main.Position = healthBarPosition + Vector2.new(0, size.Y - healthBarHeight)
        V.BoxesCache[player].HealthBar.Main.Size = Vector2.new(Config.Boxes.HealthBarWidth, healthBarHeight)
        V.BoxesCache[player].HealthBar.Main.Color = Config.Boxes.HealthBarColor
    else
        V.BoxesCache[player].HealthBar.Main.Visible = false
        V.BoxesCache[player].HealthBar.Outline.Visible = false
    end
end

local function ClearBoxesESP()
    for player, box in pairs(V.BoxesCache) do
        pcall(function()
            box.Main:Remove()
            box.Outline:Remove()
            box.HealthBar.Main:Remove()
            box.HealthBar.Outline:Remove()
        end)
    end
    V.BoxesCache = {}
    
    -- CRITICAL FIX: Disconnect all connections to prevent leaks
    if V.BoxesConnection then V.BoxesConnection:Disconnect() V.BoxesConnection = nil end
    for _, conn in pairs(V.BoxesPlayerConnections) do
        if conn then conn:Disconnect() end
    end
    V.BoxesPlayerConnections = {}
end

local function EnableBoxes()
    -- CRITICAL FIX: Always clear first to prevent stacking
    ClearBoxesESP()
    
    -- Create boxes for existing players
    for _, plr in ipairs(V.Players:GetPlayers()) do
        if plr ~= V.LP then
            CreateBoxESP(plr)
        end
    end
    
    -- Update loop (only one connection)
    V.BoxesConnection = V.RS.Heartbeat:Connect(function()
        for player, _ in pairs(V.BoxesCache) do
            UpdateBoxESP(player)
        end
    end)
    
    -- CRITICAL FIX: Managed player connections
    V.BoxesPlayerConnections[#V.BoxesPlayerConnections+1] = V.Players.PlayerAdded:Connect(function(player)
        if player ~= V.LP then
            CreateBoxESP(player)
        end
    end)
    
    V.BoxesPlayerConnections[#V.BoxesPlayerConnections+1] = V.Players.PlayerRemoving:Connect(function(player)
        if V.BoxesCache[player] then
            pcall(function()
                V.BoxesCache[player].Main:Remove()
                V.BoxesCache[player].Outline:Remove()
                V.BoxesCache[player].HealthBar.Main:Remove()
                V.BoxesCache[player].HealthBar.Outline:Remove()
            end)
            V.BoxesCache[player] = nil
        end
    end)
end

local function DisableBoxes()
    ClearBoxesESP()
end

local function UpdateBoxesVisual()
    for _, box in pairs(V.BoxesCache) do
        box.Main.Color = Config.Boxes.Color
        box.Main.Thickness = Config.Boxes.Thickness
        box.Main.Filled = false
        box.HealthBar.Main.Color = Config.Boxes.HealthBarColor
        box.HealthBar.Outline.Color = Config.Boxes.HealthBarBgColor
    end
end

-- REMOVED: Global player connections moved to EnableBoxes/DisableBoxes to prevent memory leaks

-- UI Elements for Boxes
local BoxesBox = V.Tabs.Visuals:AddRightGroupbox('Boxes')
local BoxesToggle = BoxesBox:AddToggle('BoxesEnabled', {
    Text = 'Enabled',
    Default = Config.Boxes.Enabled,
    Callback = function(v)
        Config.Boxes.Enabled = v
        if v then EnableBoxes() else DisableBoxes() end
    end
})

BoxesToggle:AddColorPicker('BoxesColor', {
    Default = Config.Boxes.Color,
    Title = 'Box Color',
    Transparency = false,
    Callback = function(c)
        Config.Boxes.Color = c
        UpdateBoxesVisual()
    end
})

-- Add Max Distance Slider
BoxesBox:AddSlider('BoxesMaxDistance', {
    Text = 'Max Distance',
    Default = Config.Boxes.MaxDistance,
    Min = 10,
    Max = 5000,
    Rounding = 0,
    Suffix = ' studs',
    Compact = true,
    Callback = function(v)
        Config.Boxes.MaxDistance = v
    end
})

local HealthBarToggle = BoxesBox:AddToggle('HealthBarEnabled', {
    Text = 'HealthBar',
    Default = Config.Boxes.HealthBarEnabled,
    Callback = function(v)
        Config.Boxes.HealthBarEnabled = v
    end
})

HealthBarToggle:AddColorPicker('HealthBarColor', {
    Default = Config.Boxes.HealthBarColor,
    Title = 'Health Color',
    Transparency = false,
    Callback = function(c)
        Config.Boxes.HealthBarColor = c
        UpdateBoxesVisual()
    end
})

HealthBarToggle:AddColorPicker('HealthBarBgColor', {
    Default = Config.Boxes.HealthBarBgColor,
    Title = 'Health BG',
    Transparency = false,
    Callback = function(c)
        Config.Boxes.HealthBarBgColor = c
        UpdateBoxesVisual()
    end
})



if Config.Boxes.Enabled then EnableBoxes() end

-- WORLD SETTINGS UI
local function ApplyWorldSettings()
    local atmosphere = game:GetService('Lighting'):FindFirstChildOfClass('Atmosphere')
    if not atmosphere then return end
    atmosphere.Color = Config.WorldSettings.Color
    atmosphere.Decay = Config.WorldSettings.Decay
    atmosphere.Glare = Config.WorldSettings.Glare
    atmosphere.Haze = Config.WorldSettings.Haze
    atmosphere.Density = Config.WorldSettings.Density
    atmosphere.Offset = Config.WorldSettings.Offset
end

-- Apply initial settings
ApplyWorldSettings()

local WorldBox = V.Tabs.Visuals:AddRightGroupbox('World Settings')

-- create dummy toggle just to host color pickers (UI lib limitation)
local WorldColorsToggle = WorldBox:AddToggle('WorldColors', {
    Text = 'Colors',
    Default = true,
    Callback = function() end
})

WorldColorsToggle:AddColorPicker('WorldColor', {
    Default = Config.WorldSettings.Color,
    Title = 'Color',
    Transparency = false,
    Callback = function(c)
        Config.WorldSettings.Color = c
        ApplyWorldSettings()
    end
})

WorldColorsToggle:AddColorPicker('WorldDecay', {
    Default = Config.WorldSettings.Decay,
    Title = 'Decay',
    Transparency = false,
    Callback = function(c)
        Config.WorldSettings.Decay = c
        ApplyWorldSettings()
    end
})

WorldBox:AddSlider('WorldGlare', {
    Text = 'Glare',
    Default = Config.WorldSettings.Glare,
    Min = 0,
    Max = 10,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.WorldSettings.Glare = v
        ApplyWorldSettings()
    end
})

-- AMBIENT SETTINGS UI
local OriginalAmbient = game:GetService('Lighting').Ambient

local function ApplyAmbient()
    local lighting = game:GetService('Lighting')
    if Config.Ambient.Enabled then
        lighting.Ambient = Config.Ambient.Color
    else
        lighting.Ambient = OriginalAmbient
    end
end

ApplyAmbient()

local AmbientBox = V.Tabs.Visuals:AddRightGroupbox('Ambient')
local AmbientToggle = AmbientBox:AddToggle('AmbientEnabled', {
    Text = 'Enabled',
    Default = Config.Ambient.Enabled,
    Callback = function(v)
        Config.Ambient.Enabled = v
        ApplyAmbient()
    end
})

AmbientToggle:AddColorPicker('AmbientColor', {
    Default = Config.Ambient.Color,
    Title = 'Color',
    Transparency = false,
    Callback = function(c)
        Config.Ambient.Color = c
        ApplyAmbient()
    end
})

-- TRAILS SETTINGS UI
local function ApplyTrail()
    local lp = V.LP
    local char = lp and lp.Character
    local hrp = char and char:FindFirstChild('HumanoidRootPart')

    if not Config.Trails.Enabled or not hrp then
        if V.TrailInstance then V.TrailInstance.Enabled = false end
        return
    end

    -- Ensure attachments
    if not V.TrailAttach0 or V.TrailAttach0.Parent ~= hrp then
        V.TrailAttach0 = Instance.new('Attachment')
        V.TrailAttach0.Name = 'SimpleBotTrailA0'
        V.TrailAttach0.Position = Vector3.new(0.5, 0, 0)
        V.TrailAttach0.Parent = hrp
    end
    if not V.TrailAttach1 or V.TrailAttach1.Parent ~= hrp then
        V.TrailAttach1 = Instance.new('Attachment')
        V.TrailAttach1.Name = 'SimpleBotTrailA1'
        V.TrailAttach1.Position = Vector3.new(-0.5, 0, 0)
        V.TrailAttach1.Parent = hrp
    end

    if not V.TrailInstance or V.TrailInstance.Parent ~= hrp then
        V.TrailInstance = Instance.new('Trail')
        V.TrailInstance.Name = 'SimpleBotTrail'
        V.TrailInstance.Parent = hrp
    end

    -- Apply properties
    V.TrailInstance.Attachment0 = V.TrailAttach0
    V.TrailInstance.Attachment1 = V.TrailAttach1
    V.TrailInstance.Color = ColorSequence.new(Config.Trails.Color)
    V.TrailInstance.Transparency = NumberSequence.new(Config.Trails.Transparency)
    V.TrailInstance.Lifetime = Config.Trails.Length
    V.TrailInstance.WidthScale = NumberSequence.new(Config.Trails.Width)
    V.TrailInstance.Enabled = true
    V.TrailInstance.MinLength = Config.Trails.MinLength
    V.TrailInstance.FaceCamera = true
end

local function SetupTrailsUI()
    -- apply immediately and on respawn
    ApplyTrail()
    if V.LP and not V._TrailCharConn then
        V._TrailCharConn = V.LP.CharacterAdded:Connect(function()
            task.defer(ApplyTrail)
        end)
    end

    local TrailsBox = V.Tabs.Visuals:AddLeftGroupbox('Trails')
    local TrailsToggle = TrailsBox:AddToggle('TrailsEnabled', {
        Text = 'Enabled',
        Default = Config.Trails.Enabled,
        Callback = function(v)
            Config.Trails.Enabled = v
            ApplyTrail()
        end
    })

    TrailsToggle:AddColorPicker('TrailsColor', {
        Title = 'Color',
        Transparency = false,
        Default = Config.Trails.Color,
        Callback = function(c)
            Config.Trails.Color = c
            ApplyTrail()
        end
    })

    TrailsBox:AddSlider('TrailsTransparency', {
        Text = 'Transparency',
        Min = 0, Max = 1, Rounding = 2, Compact = true,
        Default = Config.Trails.Transparency,
        Callback = function(v)
            Config.Trails.Transparency = v
            ApplyTrail()
        end
    })

    TrailsBox:AddSlider('TrailsLength', {
        Text = 'Length (Lifetime)',
        Min = 0, Max = 20, Rounding = 1, Compact = true,
        Default = Config.Trails.Length,
        Callback = function(v)
            Config.Trails.Length = v
            ApplyTrail()
        end
    })

    TrailsBox:AddSlider('TrailsWidth', {
        Text = 'Width',
        Min = 0, Max = 5, Rounding = 2, Compact = true,
        Default = Config.Trails.Width,
        Callback = function(v)
            Config.Trails.Width = v
            ApplyTrail()
        end
    })

    
end

SetupTrailsUI()

-- BLOOM SETTINGS UI
local function ApplyBloom()
    local lighting = game:GetService('Lighting')
    local bloom = lighting:FindFirstChild('SimpleBotBloom')
    if not Config.Bloom.Enabled then
        if bloom then bloom.Enabled = false end
        return
    end
    if not bloom then
        bloom = Instance.new('BloomEffect')
        bloom.Name = 'SimpleBotBloom'
        bloom.Parent = lighting
    end
    bloom.Enabled = true
    bloom.Intensity = Config.Bloom.Intensity
    bloom.Threshold = Config.Bloom.Threshold
    bloom.Size = Config.Bloom.Size
end

local function SetupBloomUI()
    ApplyBloom()
    local BloomBox = V.Tabs.Visuals:AddRightGroupbox('Bloom')
BloomBox:AddToggle('BloomEnabled', {
    Text = 'Enabled',
    Default = Config.Bloom.Enabled,
    Callback = function(v)
        Config.Bloom.Enabled = v
        ApplyBloom()
    end
})

BloomBox:AddSlider('BloomIntensity', {
    Text = 'Intensity',
    Default = Config.Bloom.Intensity,
    Min = 0,
    Max = 10,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.Bloom.Intensity = v
        ApplyBloom()
    end
})

BloomBox:AddSlider('BloomThreshold', {
    Text = 'Threshold',
    Default = Config.Bloom.Threshold,
    Min = 0,
    Max = 2,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.Bloom.Threshold = v
        ApplyBloom()
    end
})

BloomBox:AddSlider('BloomSize', {
    Text = 'Size',
    Default = Config.Bloom.Size,
    Min = 0,
    Max = 56,
    Rounding = 0,
    Compact = false,
    Callback = function(v)
        Config.Bloom.Size = v
        ApplyBloom()
    end
})
end

SetupBloomUI()

-- COLOR CORRECTION SETTINGS UI
local function ApplyColorCorrection()
    local lighting = game:GetService('Lighting')
    local cc = lighting:FindFirstChild('SimpleBotColorCorrection')
    if not Config.ColorCorrection.Enabled then
        if cc then cc.Enabled = false end
        return
    end
    if not cc then
        cc = Instance.new('ColorCorrectionEffect')
        cc.Name = 'SimpleBotColorCorrection'
        cc.Parent = lighting
    end
    cc.Enabled = true
    cc.Brightness = Config.ColorCorrection.Brightness
    cc.Contrast = Config.ColorCorrection.Contrast
    cc.Saturation = Config.ColorCorrection.Saturation
    cc.TintColor = Config.ColorCorrection.TintColor
end

local function SetupColorCorrectionUI()
    ApplyColorCorrection()
    local CCBox = V.Tabs.Visuals:AddRightGroupbox('Color Correction')
    local CCToggle = CCBox:AddToggle('CCEnabled', {
    Text = 'Enabled',
    Default = Config.ColorCorrection.Enabled,
    Callback = function(v)
        Config.ColorCorrection.Enabled = v
        ApplyColorCorrection()
    end
})

CCBox:AddSlider('CCBrightness', {
    Text = 'Brightness',
    Default = Config.ColorCorrection.Brightness,
    Min = -1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.ColorCorrection.Brightness = v
        ApplyColorCorrection()
    end
})

CCBox:AddSlider('CCContrast', {
    Text = 'Contrast',
    Default = Config.ColorCorrection.Contrast,
    Min = -1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.ColorCorrection.Contrast = v
        ApplyColorCorrection()
    end
})

CCBox:AddSlider('CCSaturation', {
    Text = 'Saturation',
    Default = Config.ColorCorrection.Saturation,
    Min = -1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.ColorCorrection.Saturation = v
        ApplyColorCorrection()
    end
})

CCToggle:AddColorPicker('CCTintColor', {
    Title = 'Tint Color',
    Transparency = false,
    Default = Config.ColorCorrection.TintColor,
    Callback = function(c)
        Config.ColorCorrection.TintColor = c
        ApplyColorCorrection()
    end
})
end

SetupColorCorrectionUI()

-- TIME SETTINGS UI (moved into its own initializer as well)
local OriginalClockTime = game:GetService('Lighting').ClockTime

local function ApplyTime()
    local lighting = game:GetService('Lighting')
    if not Config.Time.Enabled then
        lighting.ClockTime = OriginalClockTime
        return
    end
    lighting.ClockTime = (Config.Time.Hours % 24) + (Config.Time.Minutes / 60)
end

local function SetupTimeUI()
    ApplyTime()
    local TimeBox = V.Tabs.Visuals:AddRightGroupbox('Time')
TimeBox:AddToggle('TimeEnabled', {
    Text = 'Enabled',
    Default = Config.Time.Enabled,
    Callback = function(v)
        Config.Time.Enabled = v
        ApplyTime()
    end
})

TimeBox:AddSlider('TimeHours', {
    Text = 'Hours',
    Default = Config.Time.Hours,
    Min = 0,
    Max = 23,
    Rounding = 0,
    Compact = false,
    Callback = function(v)
        Config.Time.Hours = v
        ApplyTime()
    end
})

    TimeBox:AddSlider('TimeMinutes', {
    Text = 'Minutes',
    Default = Config.Time.Minutes,
    Min = 0,
    Max = 59,
    Rounding = 0,
    Compact = false,
    Callback = function(v)
        Config.Time.Minutes = v
        ApplyTime()
    end
    })
end

SetupTimeUI()

-- AURA (Visuals) -----------------------
-- Ensure Aura config defaults
Config.Aura = Config.Aura or {}
if Config.Aura.Enabled == nil then Config.Aura.Enabled = false end
if not Config.Aura.Type then Config.Aura.Type = 'Health' end
if not Config.Aura.Color then Config.Aura.Color = Color3.new(1,1,1) end
if Config.Aura.LightEmission == nil then Config.Aura.LightEmission = 0.6 end
-- Predeclare cached template holder
V.ChargingTemplate = V.ChargingTemplate or nil
V.FrozenTemplate = V.FrozenTemplate or nil

function V.GetBestAuraAttachment(char)
    if not char then return nil end
    local function getAttach(partName, attachName)
        local part = char:FindFirstChild(partName)
        if part then return part:FindFirstChild(attachName) end
        return nil
    end
    return 
        getAttach('UpperTorso','WaistCenterAttachment') or
        getAttach('UpperTorso','BodyBackAttachment') or
        getAttach('Torso','WaistCenterAttachment') or
        getAttach('Torso','BodyBackAttachment') or
        getAttach('HumanoidRootPart','RootAttachment')
end

function V.ClearAura()
    -- destroy previously created emitters
    for i = 1, #V.AuraEmitters do
        local e = V.AuraEmitters[i]
        if e and e.Destroy then pcall(function() e:Destroy() end) end
    end
    V.AuraEmitters = {}
end

function V.GetAuraColorSequence()
    local c = Config.Aura.Color or Color3.new(1,1,1)
    return ColorSequence.new({
        ColorSequenceKeypoint.new(0, c),
        ColorSequenceKeypoint.new(1, c),
    })
end

function V.UpdateAuraColor()
    local seq = V.GetAuraColorSequence()
    for i = 1, #V.AuraEmitters do
        local e = V.AuraEmitters[i]
        if e and e:IsA('ParticleEmitter') then
            e.Color = seq
        end
    end
end

function V.UpdateAuraLightEmission()
    local le = Config.Aura and Config.Aura.LightEmission
    if le == nil then return end
    for i = 1, #V.AuraEmitters do
        local e = V.AuraEmitters[i]
        if e and e:IsA('ParticleEmitter') then
            e.LightEmission = le
        end
    end
end

-- New: Embers aura based on provided preset, attached across multiple body parts
function V.CreateEmbersAura(char)
    if not char then return end
    local function makeOn(parentInst, props)
        if not parentInst then return end
        local pe = Instance.new('ParticleEmitter')
        for k, v in pairs(props) do pe[k] = v end
        pe.Parent = parentInst
        table.insert(V.AuraEmitters, pe)
    end
    local function getAttachOrPart(partName, attachName)
        local part = char:FindFirstChild(partName)
        if not part then return nil end
        local att = attachName and part:FindFirstChild(attachName)
        return att or part
    end

    local col = V.GetAuraColorSequence()

    -- Common emitter definitions
    local Embers1 = {
        Drag = 5,
        ZOffset = 4,
        Texture = 'rbxassetid://1084996976',
        EmissionDirection = Enum.NormalId.Bottom,
        LightEmission = 1,
        Name = 'Embers1',
        Lifetime = NumberRange.new(0.45, 0.9),
        Speed = NumberRange.new(0.001),
        Rate = 130,
        LockedToPart = true,
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0,0),
            NumberSequenceKeypoint.new(0.508,0.04,0.04),
            NumberSequenceKeypoint.new(1,0,0)
        })
    }
    local Aura1 = {
        VelocitySpread = 5,
        RotSpeed = NumberRange.new(-30,30),
        Texture = 'rbxassetid://13410359900',
        Color = col,
        Drag = 5,
        ZOffset = -1.05,
        LightEmission = 0.6,
        Rotation = NumberRange.new(-360,360),
        Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0,1,0),
            NumberSequenceKeypoint.new(0.4857,0,0),
            NumberSequenceKeypoint.new(0.6151,0,0),
            NumberSequenceKeypoint.new(1,1,0)
        }),
        Name = 'Aura1',
        Lifetime = NumberRange.new(1),
        Speed = NumberRange.new(0,2),
        SpreadAngle = Vector2.new(5,5),
        LockedToPart = true,
        Rate = 20,
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0.25,0),
            NumberSequenceKeypoint.new(1,0.9,0)
        })
    }
    local Aura2 = {
        VelocitySpread = 5,
        RotSpeed = NumberRange.new(-30,30),
        Texture = 'rbxassetid://13410359900',
        Color = col,
        LightEmission = 1,
        Drag = 5,
        ZOffset = -1,
        SpreadAngle = Vector2.new(5,5),
        Rotation = NumberRange.new(-360,360),
        Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0,1,0),
            NumberSequenceKeypoint.new(0.4857,0,0),
            NumberSequenceKeypoint.new(0.6050,0,0),
            NumberSequenceKeypoint.new(1,1,0)
        }),
        Name = 'Aura2',
        Lifetime = NumberRange.new(1),
        Speed = NumberRange.new(0,1),
        Rate = 18,
        LockedToPart = true,
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0.25,0),
            NumberSequenceKeypoint.new(1,1.2,0)
        })
    }

    -- Head
    local headParent = getAttachOrPart('Head', 'FaceCenterAttachment')
    makeOn(headParent, Embers1)
    makeOn(headParent, Aura1)
    makeOn(headParent, Aura2)

    -- Left Arm
    local lArmParent = getAttachOrPart('LeftUpperArm', 'LeftShoulderRigAttachment') or getAttachOrPart('Left Arm', 'LeftShoulderAttachment')
    makeOn(lArmParent, Embers1)
    makeOn(lArmParent, Aura1)
    makeOn(lArmParent, Aura2)

    -- Right Arm
    local rArmParent = getAttachOrPart('RightUpperArm', 'RightShoulderRigAttachment') or getAttachOrPart('Right Arm', 'RightShoulderAttachment')
    makeOn(rArmParent, Embers1)
    makeOn(rArmParent, Aura1)
    makeOn(rArmParent, Aura2)

    -- Left Leg
    local lLegParent = getAttachOrPart('LeftFoot', 'LeftFootAttachment') or getAttachOrPart('Left Leg', 'LeftFootAttachment')
    makeOn(lLegParent, Embers1)
    makeOn(lLegParent, Aura1)
    makeOn(lLegParent, Aura2)

    -- Right Leg
    local rLegParent = getAttachOrPart('RightFoot', 'RightFootAttachment') or getAttachOrPart('Right Leg', 'RightFootAttachment')
    makeOn(rLegParent, Embers1)
    makeOn(rLegParent, Aura1)
    makeOn(rLegParent, Aura2)

    -- Torso/Core
    local torsoParent = getAttachOrPart('UpperTorso', 'WaistCenterAttachment') or getAttachOrPart('Torso', 'WaistCenterAttachment')
    makeOn(torsoParent, Embers1)
    makeOn(torsoParent, Aura1)
    makeOn(torsoParent, Aura2)
end

-- New: Charging aura built from provided model data (used as a template)
function V._GetChargingTemplate()
    if V.ChargingTemplate and V.ChargingTemplate.Parent == nil then
        -- keep cached instance even if not parented
        return V.ChargingTemplate
    end
    if V.ChargingTemplate and V.ChargingTemplate.Parent then
        return V.ChargingTemplate
    end

    local partsWithId = {}
    local awaitRef = {}

    local root = {
        ID = 0;
        Type = "Model";
        Properties = {
            Name = "Charging-VFX-01";
            PrimaryPart = "_R:17_";
        };
        Children = { -- truncated non-essential CFrame/Position values preserved where relevant
            { ID = 21; Type = "MeshPart"; Properties = { Name = "Torso"; MeshId = "rbxassetid://11697594497"; Material = Enum.Material.SmoothPlastic; }; Children = {
                { ID = 35; Type = "Attachment"; Properties = { Name = "Main"; }; Children = {
                    { ID = 36; Type = "ParticleEmitter"; Properties = { ZOffset = 4; Texture = "rbxassetid://4509687978"; VelocitySpread = -360; LightEmission = 1; Name = "Main-Core-02"; Lifetime = NumberRange.new(0.25,0.5); Speed = NumberRange.new(0.5,1); SpreadAngle = Vector2.new(-360,630); Rate = 50; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.35,0),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
                    { ID = 37; Type = "ParticleEmitter"; Properties = { VelocitySpread = -360; RotSpeed = NumberRange.new(-35,35); Texture = "rbxassetid://10357918337"; LightEmission = 1; Drag = 4; ZOffset = -1; SpreadAngle = Vector2.new(-360,360); Rotation = NumberRange.new(-360,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.2724514603614807,0.768750011920929,0.018750011920928955),NumberSequenceKeypoint.new(1,1,0)}); Name = "Wind"; Lifetime = NumberRange.new(0.4,0.6); Speed = NumberRange.new(0.001); Rate = 15; LockedToPart = true; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,4.8125,0),NumberSequenceKeypoint.new(0.21905340254306793,2.562499523162842,0),NumberSequenceKeypoint.new(0.4205097258090973,1.3749998807907104,0),NumberSequenceKeypoint.new(0.553398072719574,0.6874996423721313,0),NumberSequenceKeypoint.new(0.7050970792770386,0.3125,0),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} },
                    { ID = 38; Type = "ParticleEmitter"; Properties = { LockedToPart = true; ZOffset = 1; Texture = "rbxassetid://12363772245"; Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Main-Core-01"; Lifetime = NumberRange.new(0.25,0.5); Speed = NumberRange.new(0); LightEmission = 1; Rate = 25; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,0.5,0.125),NumberSequenceKeypoint.new(1,0.5,0.125)}); }; Children = {} },
                    { ID = 39; Type = "ParticleEmitter"; Properties = { LockedToPart = true; ZOffset = 2; Texture = "rbxassetid://6865222957"; Rotation = NumberRange.new(-36,360); Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(0.5,0,0),NumberSequenceKeypoint.new(1,1,0)}); Name = "Charge"; Lifetime = NumberRange.new(0.125,0.25); Speed = NumberRange.new(0); LightEmission = 1; Rate = 100; Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2,0),NumberSequenceKeypoint.new(1,0,0)}); }; Children = {} }
                } },
            } } -- Torso
        }
    }

    local function Scan(item, parent)
        local obj = Instance.new(item.Type)
        if (item.ID) then
            local awaiting = awaitRef[item.ID]
            if (awaiting) then
                awaiting[1][awaiting[2]] = obj
                awaitRef[item.ID] = nil
            else
                partsWithId[item.ID] = obj
            end
        end
        for p,v in pairs(item.Properties) do
            if (type(v) == "string") then
                local id = tonumber(v:match("^_R:(%w+)_$"))
                if (id) then
                    if (partsWithId[id]) then
                        v = partsWithId[id]
                    else
                        awaitRef[id] = {obj, p}
                        v = nil
                    end
                end
            end
            obj[p] = v
        end
        for _,c in pairs(item.Children) do
            Scan(c, obj)
        end
        obj.Parent = parent
        return obj
    end

    V.ChargingTemplate = Scan(root, nil)
    return V.ChargingTemplate
end

function V.CreateChargingAura(attach)
    if not attach then return end
    local template = V._GetChargingTemplate()
    if not template then return end
    local torso = template:FindFirstChild("Torso")
    if not torso then return end
    local main = torso:FindFirstChild("Main")
    if not main or not main:IsA('Attachment') then return end

    for _, child in ipairs(main:GetChildren()) do
        if child:IsA('ParticleEmitter') then
            local pe = child:Clone()
            pe.Color = V.GetAuraColorSequence()
            pe.Parent = attach
            table.insert(V.AuraEmitters, pe)
        end
    end
end

function V.CreateHealthAura(attach)
    if not attach then return end
    -- Helper to make emitter
    local function makeEmitter(props)
        local pe = Instance.new('ParticleEmitter')
        for k, val in pairs(props) do pe[k] = val end
        pe.Parent = attach
        table.insert(V.AuraEmitters, pe)
        return pe
    end
    -- Cubes
    makeEmitter({
        Name = 'Cubes',
        Texture = 'rbxassetid://9470888178',
        Acceleration = Vector3.new(0,5,0),
        RotSpeed = NumberRange.new(-300,300),
        VelocitySpread = 360,
        Color = V.GetAuraColorSequence(),
        Drag = 7,
        ZOffset = 2,
        Rotation = NumberRange.new(-360,360),
        LightEmission = 0.6,
        Lifetime = NumberRange.new(1,1.5),
        Speed = NumberRange.new(25),
        SpreadAngle = Vector2.new(360,360),
        LockedToPart = true,
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0),
            NumberSequenceKeypoint.new(0.25,0.65),
            NumberSequenceKeypoint.new(1,0)
        })
    })
    -- ShockWave removed
    -- Light
    makeEmitter({
        Name = 'Light',
        Texture = 'rbxassetid://1075864321',
        LightEmission = 0.6,
        EmissionDirection = Enum.NormalId.Front,
        Lifetime = NumberRange.new(1.3),
        Speed = NumberRange.new(0.001),
        Rotation = NumberRange.new(-360,360),
        Rate = 2,
        ZOffset = -1,
        LockedToPart = true,
        Color = V.GetAuraColorSequence(),
        Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0,1),
            NumberSequenceKeypoint.new(0.5,0.74),
            NumberSequenceKeypoint.new(1,1)
        }),
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,4.5),
            NumberSequenceKeypoint.new(1,4.5)
        })
    })
    -- Stars
    makeEmitter({
        Name = 'Stars',
        Texture = 'rbxassetid://1851669703',
        LightEmission = 1,
        EmissionDirection = Enum.NormalId.Front,
        Lifetime = NumberRange.new(1),
        Speed = NumberRange.new(0),
        Rotation = NumberRange.new(-360,360),
        Rate = 4,
        ZOffset = 1,
        LockedToPart = true,
        Color = V.GetAuraColorSequence(),
        Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0,1),
            NumberSequenceKeypoint.new(0.5,0),
            NumberSequenceKeypoint.new(1,1)
        }),
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,2,1),
            NumberSequenceKeypoint.new(1,2,1)
        })
    })
    -- Health
    makeEmitter({
        Name = 'Health',
        Texture = 'rbxassetid://12072054746',
        VelocitySpread = 360,
        RotSpeed = NumberRange.new(-15,15),
        LightEmission = 0,
        Drag = 5,
        ZOffset = 1,
        SpreadAngle = Vector2.new(360,360),
        Rotation = NumberRange.new(-5,5),
        Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0),
            NumberSequenceKeypoint.new(0.5,0),
            NumberSequenceKeypoint.new(1,0.21)
        }),
        Lifetime = NumberRange.new(1),
        Speed = NumberRange.new(35),
        Rate = 12,
        LockedToPart = true,
        Color = V.GetAuraColorSequence(),
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0),
            NumberSequenceKeypoint.new(0.14,0.81),
            NumberSequenceKeypoint.new(0.79,0.81),
            NumberSequenceKeypoint.new(1,0)
        })
    })
    -- Arrow
    makeEmitter({
        Name = 'Arrow',
        Texture = 'rbxassetid://14403995847',
        Drag = 5,
        ZOffset = 4,
        LightEmission = 0,
        Lifetime = NumberRange.new(1),
        Speed = NumberRange.new(0.5,1.2),
        Rate = 10,
        LockedToPart = true,
        Color = V.GetAuraColorSequence(),
        Size = NumberSequence.new({
            NumberSequenceKeypoint.new(0,0),
            NumberSequenceKeypoint.new(0.14,0.53),
            NumberSequenceKeypoint.new(0.9,0.56),
            NumberSequenceKeypoint.new(1,0)
        })
    })
end

function V.BuildAuraForCharacter(char)
    V.ClearAura()
    local attach = V.GetBestAuraAttachment(char)
    if Config.Aura.Type == 'Health' then
        if not attach then return end
        V.CreateHealthAura(attach)
    elseif Config.Aura.Type == 'Embers' then
        V.CreateEmbersAura(char)
    elseif Config.Aura.Type == 'Charging' then
        if not attach then return end
        V.CreateChargingAura(attach)
    elseif Config.Aura.Type == 'Frozen' then
        V.CreateFrozenAura(char)
    end
    -- apply current light emission setting to all created emitters
    V.UpdateAuraLightEmission()
end

function V.ApplyAura()
    if not Config.Aura.Enabled then
        V.ClearAura()
        return
    end
    local char = V.LP and V.LP.Character
    if char then V.BuildAuraForCharacter(char) end
end

function V.SetupAuraUI()
    -- initial apply and connect character changes
    V.ApplyAura()
    if V.AuraCharacterConn then V.AuraCharacterConn:Disconnect() end
    if V.LP then
        V.AuraCharacterConn = V.LP.CharacterAdded:Connect(function(char)
            if Config.Aura.Enabled then
                -- delay to ensure attachments exist
                task.defer(function() V.ApplyAura() end)
            end
        end)
    end

    local AuraBox = V.Tabs.Visuals:AddRightGroupbox('Aura')
    local AuraToggle = AuraBox:AddToggle('AuraEnabled', {
        Text = 'Enabled',
        Default = Config.Aura.Enabled,
        Callback = function(v)
            Config.Aura.Enabled = v
            V.ApplyAura()
        end
    })

    AuraToggle:AddColorPicker('AuraColor', {
        Default = Config.Aura.Color,
        Title = 'Color',
        Transparency = false,
        Callback = function(c)
            Config.Aura.Color = c
            V.UpdateAuraColor()
        end
    })

    -- ensure default for light emission
    if Config.Aura.LightEmission == nil then
        Config.Aura.LightEmission = 0.6
    end
    AuraBox:AddSlider('AuraLightEmission', {
        Text = 'Light Emission',
        Default = Config.Aura.LightEmission,
        Min = 0,
        Max = 1,
        Rounding = 2,
        Compact = false,
        Callback = function(v)
            Config.Aura.LightEmission = v
            V.UpdateAuraLightEmission()
        end
    })

    AuraBox:AddDropdown('AuraType', {
        Values = {'Health','Embers','Charging','Frozen'},
        Default = Config.Aura.Type,
        Multi = false,
        Text = 'Type',
        Callback = function(val)
            Config.Aura.Type = val
            if Config.Aura.Enabled then V.ApplyAura() end
        end
    })
end

V.SetupAuraUI()

WorldBox:AddSlider('WorldHaze', {
    Text = 'Haze',
    Default = Config.WorldSettings.Haze,
    Min = 0,
    Max = 10,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.WorldSettings.Haze = v
        ApplyWorldSettings()
    end
})

WorldBox:AddSlider('WorldDensity', {
    Text = 'Density',
    Default = Config.WorldSettings.Density,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.WorldSettings.Density = v
        ApplyWorldSettings()
    end
})

WorldBox:AddSlider('WorldOffset', {
    Text = 'Offset',
    Default = Config.WorldSettings.Offset,
    Min = -1,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(v)
        Config.WorldSettings.Offset = v
        ApplyWorldSettings()
    end
})

-- SHOW HITBOX SYSTEM
local function ShowTargetHitbox()
    if not V.Target or not V.Target.player or not V.Target.player.Character then
        if V.CurrentHitbox then
            V.CurrentHitbox.Transparency = V.OriginalHitboxTransparency or 1
            V.CurrentHitbox.Material = V.OriginalHitboxMaterial or Enum.Material.Plastic
            V.CurrentHitbox = nil
            V.OriginalHitboxTransparency = nil
            V.OriginalHitboxMaterial = nil
        end
        return
    end
    
    local hitbox = V.Target.player.Character:FindFirstChild('Hitbox')
    if not hitbox then return end
    
    -- If new hitbox, save original properties
    if V.CurrentHitbox ~= hitbox then
        -- Restore previous hitbox if exists
        if V.CurrentHitbox then
            V.CurrentHitbox.Transparency = V.OriginalHitboxTransparency or 1
            V.CurrentHitbox.Material = V.OriginalHitboxMaterial or Enum.Material.Plastic
        end
        
        -- Set new hitbox
        V.CurrentHitbox = hitbox
        V.OriginalHitboxTransparency = hitbox.Transparency
        V.OriginalHitboxMaterial = hitbox.Material
    end
    
    -- Apply hitbox visualization
    if Config.Aimbot.ShowHitbox then
        V.CurrentHitbox.Transparency = 0.6
        V.CurrentHitbox.Color = Config.Aimbot.HitboxColor
        V.CurrentHitbox.Material = Enum.Material[Config.Aimbot.HitboxMaterial]
    else
        V.CurrentHitbox.Transparency = V.OriginalHitboxTransparency or 1
        V.CurrentHitbox.Material = V.OriginalHitboxMaterial or Enum.Material.Plastic
    end
end

local function DisableHitbox()
    if V.CurrentHitbox then
        V.CurrentHitbox.Transparency = V.OriginalHitboxTransparency or 1
        V.CurrentHitbox.Material = V.OriginalHitboxMaterial or Enum.Material.Plastic
        V.CurrentHitbox = nil
        V.OriginalHitboxTransparency = nil
        V.OriginalHitboxMaterial = nil
    end
end

-- UI Elements for ShowHitbox in Aimbot tab
V.UI.Boxes = V.UI.Boxes or {}
V.UI.Boxes.ShowHitbox = V.Tabs.Aimbot:AddLeftGroupbox('ShowHitbox')
V.UI.ShowHitboxToggle = V.UI.Boxes.ShowHitbox:AddToggle('ShowHitboxEnabled', {
    Text = 'ShowHitbox',
    Default = Config.Aimbot.ShowHitbox,
    Callback = function(v)
        Config.Aimbot.ShowHitbox = v
        if not v then DisableHitbox() end
    end
})

V.UI.ShowHitboxToggle:AddColorPicker('HitboxColor', {
    Default = Config.Aimbot.HitboxColor,
    Title = 'Hitbox Color',
    Transparency = false,
    Callback = function(c)
        Config.Aimbot.HitboxColor = c
    end
})

V.UI.Boxes.ShowHitbox:AddDropdown('HitboxMaterial', {
    Values = {'Glass', 'Neon', 'ForceField'},
    Default = Config.Aimbot.HitboxMaterial,
    Multi = false,
    Text = 'Material',  
    Callback = function(v)
        Config.Aimbot.HitboxMaterial = v
    end
})

V.UI.Boxes = V.UI.Boxes or {}
V.UI.Boxes.HitSound = V.Tabs.Aimbot:AddLeftGroupbox('HitSound')

V.UI.TempToggle = V.UI.Boxes.HitSound:AddToggle('HitSoundEnabled', {
    Text = 'Enable HitSound',
    Default = Config.HitSound.Enabled,
    Callback = function(v)
        Config.HitSound.Enabled = v
    end
})

V.UI.Boxes.HitSound:AddDropdown('HitSoundSelect', {
    Values = AvailableHitSounds,
    Default = Config.HitSound.Sound,
    Multi = false,
    Text = 'Sound',
    Callback = function(v)
        Config.HitSound.Sound = v
    end
})

V.UI.Boxes.HitSound:AddSlider('HitSoundVolume', {
    Text = 'Volume',
    Min = 0,
    Max = 5,
    Default = Config.HitSound.Volume,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.HitSound.Volume = v
    end
})

V.UI.Boxes.HitSound:AddSlider('HitSoundPitch', {
    Text = 'Pitch',
    Min = 0.3,
    Max = 3,
    Default = Config.HitSound.Pitch,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.HitSound.Pitch = v
    end
})

-- используем кеш-функцию в V вместо локальной, форвард не требуется

-- Подготовим пространство имён для звуков, чтобы избежать ошибок типизатора
V.Sound = V.Sound or {}
V.Sound.MuteExistingSounds = V.Sound.MuteExistingSounds or function() end

V.UI.Boxes.HitSound:AddToggle('HitSoundMuteOriginal', {
    Text = 'Mute Original Sounds',
    Default = Config.HitSound.MuteOriginal,
    Callback = function(v)
        Config.HitSound.MuteOriginal = v
        -- Применяем изменения к существующим звукам
        if v and V.Sound and V.Sound.MuteExistingSounds then V.Sound.MuteExistingSounds() end
    end
})

-- IMPROVED SOUND MUTING SYSTEM
-- Гарантируем список целевых звуков в кеше V.Sound (не расширяем тип Config)
V.Sound.TargetIds = V.Sound.TargetIds or {
    "rbxassetid://6773912589",
    "6773912589",
    "http://www.roblox.com/asset/?id=6773912589"
}

-- Функция для проверки и блокировки звука (кешируем в V.Sound, не локальная)
function V.Sound.MuteTargetSound(sound)
    if not sound:IsA("Sound") then return end
    
    local soundId = tostring(sound.SoundId):lower()
    for _, targetId in pairs(V.Sound.TargetIds) do
        if soundId:find(targetId:lower()) then
            if Config.HitSound.MuteOriginal then
                pcall(function()
                    sound:Stop()
                    sound.Volume = 0
                    sound.Playing = false
                end)
                -- Блокируем повторное воспроизведение
                sound:GetPropertyChangedSignal("Playing"):Connect(function()
                    if Config.HitSound.MuteOriginal and sound.Playing then
                        sound:Stop()
                        sound.Volume = 0
                    end
                end)
                return true
            end
        end
    end
    return false
end

-- Блокируем существующие звуки при включении (кешируем в V.Sound)
function V.Sound.MuteExistingSounds()
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("Sound") then
            V.Sound.MuteTargetSound(obj)
        end
    end
end

-- Отслеживание новых звуков через game.DescendantAdded (избегаем отдельного сервиса)

-- Отслеживаем звуки во всей игре
game.DescendantAdded:Connect(function(obj)
    if obj:IsA("Sound") then
        V.Sound.MuteTargetSound(obj)
    end
end)

-- SIMPLIFIED GUN EXPLOIT SYSTEM

-- Переводим функции в V.Gun, чтобы не плодить локальные переменные в верхнем скоупе
V.Gun = V.Gun or {}

function V.Gun.EquipRevolver()
    local revolver = V.LP.Backpack:FindFirstChild("[Revolver]") or (V.LP.Character and V.LP.Character:FindFirstChild("[Revolver]"))
    if revolver and revolver.Parent == V.LP.Backpack then
        revolver.Parent = V.LP.Character
        V.CurrentWeapon = revolver
        return true
    elseif revolver and revolver.Parent == V.LP.Character then
        V.CurrentWeapon = revolver
        return true
    end
    return false
end

function V.Gun.CheckAutoReload()
    if not Config.Aimbot.AutoReload or not V.CurrentWeapon then return end
    
    V.WeaponCache.Ammo = V.CurrentWeapon:FindFirstChild("Ammo")
    if V.WeaponCache.Ammo and V.WeaponCache.Ammo.Value <= 0 then
        V.FuncCache.CurrentTime = tick()
        if V.FuncCache.CurrentTime - V.LastReloadTime > 0.5 then -- Prevent spam
            V.LastReloadTime = V.FuncCache.CurrentTime
            -- Trigger reload
            V.WeaponCache.ReloadEvent = V.CurrentWeapon:FindFirstChild("Reload")
            if V.WeaponCache.ReloadEvent and V.WeaponCache.ReloadEvent:IsA("RemoteEvent") then
                V.WeaponCache.ReloadEvent:FireServer()
            end
        end
    end
end

function V.Gun.Update()
    if not Config.Aimbot.GunExploitEnabled then return end
    
    -- Auto equip revolver
    if Config.Aimbot.AutoEquipRevolver then
        if not V.CurrentWeapon or not V.CurrentWeapon.Parent then
            V.Gun.EquipRevolver()
        end
    end
    
    -- Auto reload
    V.Gun.CheckAutoReload()
end

function V.Gun.Disable()
    if V.AutoReloadConnection then
        V.AutoReloadConnection:Disconnect()
        V.AutoReloadConnection = nil
    end
    V.CurrentWeapon = nil
end

-- Character respawn handler for gun exploit
V.LP.CharacterAdded:Connect(function()
    V.CurrentWeapon = nil
    V.LastReloadTime = 0
end)

-- Main RenderStepped loop for AutoStomp & Highlights
-- CRITICAL FIX: Always disconnect existing connection to prevent stacking
if V.MainLoopConnection then 
    V.MainLoopConnection:Disconnect() 
    V.MainLoopConnection = nil 
end

-- Оптимизация: счетчик для уменьшения частоты обновления хайлайтов
V.HighlightUpdateCounter = 0
V.HighlightUpdateInterval = V.HighlightUpdateInterval or 3 -- Обновляем хайлайты каждые 3 кадра вместо каждого

V.MainLoopConnection = V.RS.RenderStepped:Connect(function()
    -- Обновляем хайлайты реже для оптимизации
    V.HighlightUpdateCounter = V.HighlightUpdateCounter + 1
    if V.HighlightUpdateCounter >= V.HighlightUpdateInterval then
        UpdateTargetHighlight()
        V.HighlightUpdateCounter = 0
    end
    
    UpdateViewTarget()
    ShowTargetHitbox()
    V.Gun.Update()
    -- ApplyAutoStomp уже проверяет наличие цели и флага
    ApplyAutoStomp()
    -- Обрабатываем отложенные HitChams эффекты
    ProcessHitChams()
end)

-- Target character event handlers
if V.Target and V.Target.player then
    V.Target.player.CharacterRemoving:Connect(function()
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
    end)
    
    V.Target.player.CharacterAdded:Connect(function(character)
        if V.CurrentHighlight then
            V.CurrentHighlight.Adornee = character
        end
    end)
end

-----------------------
-- GRAVITY MODULE
-----------------------

-- Переводим функции и состояние в V.Gravity
V.Gravity = V.Gravity or { Changed = false, Connection = nil, Original = nil }
-- Сохраняем оригинальную гравитацию один раз при старте
if V.Gravity.Original == nil then
    V.Gravity.Original = V.WS.Gravity
end

-- Gravity functions
function V.Gravity.Enable()
    if Config.Gravity.Mode == 'Workspace' then
        -- Сохраняем оригинальную гравитацию только один раз
        if V.Gravity.Original == nil then
            V.Gravity.Original = V.WS.Gravity
        end
        V.WS.Gravity = Config.Gravity.Value
        V.Gravity.Connection = V.WS:GetPropertyChangedSignal('Gravity'):Connect(function()
            if V.Gravity.Changed then return end
            V.Gravity.Changed = true
            V.WS.Gravity = Config.Gravity.Value
            V.Gravity.Changed = false
        end)
    else
        V.Gravity.Connection = V.RS.PreSimulation:Connect(function(dt)
            if V.LP.Character and V.LP.Character:FindFirstChild('Humanoid') and V.LP.Character:FindFirstChild('HumanoidRootPart') then
                local humanoid = V.LP.Character.Humanoid
                local root = V.LP.Character.HumanoidRootPart
                
                if humanoid.FloorMaterial == Enum.Material.Air then
                    if Config.Gravity.Mode == 'Impulse' then
                        root:ApplyImpulse(V.V3(0, dt * (V.WS.Gravity - Config.Gravity.Value), 0) * root.AssemblyMass)
                    else -- LinearVelocity
                        root.AssemblyLinearVelocity = root.AssemblyLinearVelocity + V.V3(0, dt * (V.WS.Gravity - Config.Gravity.Value), 0)
                    end
                end
            end
        end)
    end
end

function V.Gravity.Disable()
    if V.Gravity.Connection then
        V.Gravity.Connection:Disconnect()
        V.Gravity.Connection = nil
    end
    
    -- Всегда восстанавливаем исходную гравитацию, сохраненную при запуске
    if V.Gravity.Original ~= nil and Config.Gravity.Mode == 'Workspace' then
        V.WS.Gravity = V.Gravity.Original
    end
end

-- Gravity toggle handler
function V.Gravity.Toggle(enabled)
    if enabled then
        V.Gravity.Enable()
    else
        V.Gravity.Disable()
    end
end

-- Create Gravity UI in Misc tab (без локалов)
V.UI.Boxes = V.UI.Boxes or {}
V.UI.Boxes.Gravity = V.Tabs.Misc:AddRightGroupbox('Gravity')

V.UI.Boxes.Gravity:AddToggle('GravityEnabled', {
    Text = 'Enable Gravity',
    Default = Config.Gravity.Enabled,
    Tooltip = 'Включить/выключить модуль Gravity',
    Callback = function(v)
        Config.Gravity.Enabled = v
        V.Gravity.Toggle(v)
    end
})

V.UI.Boxes.Gravity:AddDropdown('GravityMode', {
    Values = {'Workspace', 'Impulse', 'LinearVelocity'},
    Default = table.find({'Workspace', 'Impulse', 'LinearVelocity'}, Config.Gravity.Mode) or 1,
    Multi = false,
    Text = 'Mode',
    Tooltip = 'Режим изменения гравитации',
    Callback = function(v)
        Config.Gravity.Mode = v
        if Config.Gravity.Enabled then
            V.Gravity.Disable()
            V.Gravity.Enable()
        end
    end
})

V.UI.Boxes.Gravity:AddSlider('GravityValue', {
    Text = 'Gravity Value',
    Default = Config.Gravity.Value,
    Min = 0,
    Max = 500,
    Rounding = 1,
    Compact = false,
    Callback = function(v)
        Config.Gravity.Value = v
        if Config.Gravity.Enabled and Config.Gravity.Mode == 'Workspace' then
            V.WS.Gravity = v
        end
    end
})

-- Если при старте модуль Gravity выключен, восстановим оригинальную гравитацию
if not Config.Gravity.Enabled and V.Gravity and V.Gravity.Original ~= nil and Config.Gravity.Mode == 'Workspace' then
    V.WS.Gravity = V.Gravity.Original
end

-----------------------
-- STRAFE MODULE
-----------------------

V.Strafe = V.Strafe or { Connection = nil }

function V.Strafe.Enable()
    if V.Strafe.Connection then
        V.Strafe.Connection:Disconnect()
        V.Strafe.Connection = nil
    end
    -- Подстраховка значения силы
    if type(Config.Strafe) ~= 'table' then Config.Strafe = {Enabled=false, Strength=2} end
    if type(Config.Strafe.Strength) ~= 'number' then Config.Strafe.Strength = 2 end

    V.Strafe.Connection = V.RS.PreSimulation:Connect(function(dt)
        if not (Config.Strafe and Config.Strafe.Enabled) then return end

        local char = V.LP.Character; if not char then return end
        local hum = char:FindFirstChildOfClass('Humanoid'); if not hum then return end
        local hrp = char:FindFirstChild('HumanoidRootPart'); if not hrp then return end

        -- В воздухе ускоряемся по MoveDirection сдвигом CFrame
        local fm = hum.FloorMaterial
        if fm ~= Enum.Material.Air then return end

        local dir = hum.MoveDirection
        if dir.Magnitude <= 0 then return end

        local strength = V.math.clamp(tonumber(Config.Strafe.Strength) or 2, 0.1, 10)
        local horiz = V.V3(dir.X, 0, dir.Z)
        if horiz.Magnitude > 0 then
            local offset = horiz.Unit * strength * (dt * 10)
            hrp.CFrame = hrp.CFrame + offset
        end
    end)
end

function V.Strafe.Disable()
    if V.Strafe.Connection then
        V.Strafe.Connection:Disconnect()
        V.Strafe.Connection = nil
    end
end

function V.Strafe.Toggle(enabled)
    if enabled then
        V.Strafe.Enable()
    else
        V.Strafe.Disable()
    end
end

function V.Strafe.SetStrength(val)
    local num = tonumber(val)
    if num then
        Config.Strafe.Strength = V.math.clamp(num, 0.1, 10)
    end
end

-- Автоинициализация модулей по конфигу при старте
if Config.Gravity and Config.Gravity.Enabled then
    V.Gravity.Enable()
end
if Config.Strafe and Config.Strafe.Enabled then
    V.Strafe.Enable()
end

-- Target character event handlers
if V.Target and V.Target.player then
    V.Target.player.CharacterRemoving:Connect(function()
        if V.CurrentHighlight then
            V.CurrentHighlight:Destroy()
            V.CurrentHighlight = nil
        end
    end)
    
    V.Target.player.CharacterAdded:Connect(function(character)
        if V.CurrentHighlight then
            V.CurrentHighlight.Adornee = character
        end
    end)
end

-----------------------
-- GRAVITY MODULE
-----------------------

-- Character respawn handler for gun exploit
V.LP.CharacterAdded:Connect(function()
    V.CurrentWeapon = nil
    V.LastReloadTime = 0
end)

-- Main RenderStepped loop for AutoStomp & Highlights
-- CRITICAL FIX: Always disconnect existing connection to prevent stacking
if V.MainLoopConnection then 
    V.MainLoopConnection:Disconnect() 
    V.MainLoopConnection = nil 
end

-- Оптимизация: счетчик для уменьшения частоты обновления хайлайтов
V.HighlightUpdateCounter = 0
V.HighlightUpdateInterval = V.HighlightUpdateInterval or 3 -- Обновляем хайлайты каждые 3 кадра вместо каждого

V.MainLoopConnection = V.RS.RenderStepped:Connect(function()
    -- Обновляем хайлайты реже для оптимизации
    V.HighlightUpdateCounter = V.HighlightUpdateCounter + 1
    if V.HighlightUpdateCounter >= V.HighlightUpdateInterval then
        UpdateTargetHighlight()
        V.HighlightUpdateCounter = 0
    end
    
    UpdateViewTarget()
    ShowTargetHitbox()
    V.Gun.Update()
    -- ApplyAutoStomp уже проверяет наличие цели и флага
    ApplyAutoStomp()
    -- Обрабатываем отложенные HitChams эффекты
    ProcessHitChams()
end)
